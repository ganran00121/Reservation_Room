import {
  ScrollGrid,
  TimelineHeader,
  TimelineLane,
  TimelineLaneBg,
  TimelineLaneSlicer,
  TimelineSlats,
  buildSlatCols,
  buildTimelineDateProfile,
  coordToCss,
  index,
  index2
} from "./chunk-MVCZDU7U.js";
import "./chunk-T7UM46HU.js";
import {
  BaseComponent,
  CalendarImpl,
  ContentContainer,
  DateComponent,
  EventImpl,
  NowIndicatorContainer,
  NowTimer,
  PositionCache,
  RefMap,
  Splitter,
  ViewContainer,
  _,
  combineEventUis,
  compareByFieldSpecs,
  config,
  createEventUi,
  createPlugin,
  d,
  elementClosest,
  filterHash,
  findElements,
  flexibleCompare,
  getStickyFooterScrollbar,
  getStickyHeaderDates,
  greatestDurationDenominator,
  guid,
  identity,
  injectStyles,
  isArraysEqual,
  isPropsEqual,
  isPropsValid,
  mapHash,
  memoize,
  memoizeObjArg,
  mergeEventStores,
  parseBusinessHours,
  parseClassNames,
  parseFieldSpecs,
  rangesEqual,
  rangesIntersect,
  refineProps,
  renderScrollShim,
  requestJson,
  unpromisify,
  y
} from "./chunk-XQEK2WQY.js";
import "./chunk-RSJERJUL.js";

// node_modules/@fullcalendar/resource/internal-common.js
var PRIVATE_ID_PREFIX = "_fc:";
var RESOURCE_REFINERS = {
  id: String,
  parentId: String,
  children: identity,
  title: String,
  businessHours: identity,
  extendedProps: identity,
  // event-ui
  eventEditable: Boolean,
  eventStartEditable: Boolean,
  eventDurationEditable: Boolean,
  eventConstraint: identity,
  eventOverlap: Boolean,
  eventAllow: identity,
  eventClassNames: parseClassNames,
  eventBackgroundColor: String,
  eventBorderColor: String,
  eventTextColor: String,
  eventColor: String
};
function parseResource(raw, parentId = "", store, context) {
  let { refined, extra } = refineProps(raw, RESOURCE_REFINERS);
  let resource = {
    id: refined.id || PRIVATE_ID_PREFIX + guid(),
    parentId: refined.parentId || parentId,
    title: refined.title || "",
    businessHours: refined.businessHours ? parseBusinessHours(refined.businessHours, context) : null,
    ui: createEventUi({
      editable: refined.eventEditable,
      startEditable: refined.eventStartEditable,
      durationEditable: refined.eventDurationEditable,
      constraint: refined.eventConstraint,
      overlap: refined.eventOverlap,
      allow: refined.eventAllow,
      classNames: refined.eventClassNames,
      backgroundColor: refined.eventBackgroundColor,
      borderColor: refined.eventBorderColor,
      textColor: refined.eventTextColor,
      color: refined.eventColor
    }, context),
    extendedProps: Object.assign(Object.assign({}, extra), refined.extendedProps)
  };
  Object.freeze(resource.ui.classNames);
  Object.freeze(resource.extendedProps);
  if (store[resource.id])
    ;
  else {
    store[resource.id] = resource;
    if (refined.children) {
      for (let childInput of refined.children) {
        parseResource(childInput, resource.id, store, context);
      }
    }
  }
  return resource;
}
function getPublicId(id) {
  if (id.indexOf(PRIVATE_ID_PREFIX) === 0) {
    return "";
  }
  return id;
}
var ResourceApi = class {
  constructor(_context, _resource) {
    this._context = _context;
    this._resource = _resource;
  }
  setProp(name, value) {
    let oldResource = this._resource;
    this._context.dispatch({
      type: "SET_RESOURCE_PROP",
      resourceId: oldResource.id,
      propName: name,
      propValue: value
    });
    this.sync(oldResource);
  }
  setExtendedProp(name, value) {
    let oldResource = this._resource;
    this._context.dispatch({
      type: "SET_RESOURCE_EXTENDED_PROP",
      resourceId: oldResource.id,
      propName: name,
      propValue: value
    });
    this.sync(oldResource);
  }
  sync(oldResource) {
    let context = this._context;
    let resourceId = oldResource.id;
    this._resource = context.getCurrentData().resourceStore[resourceId];
    context.emitter.trigger("resourceChange", {
      oldResource: new ResourceApi(context, oldResource),
      resource: this,
      revert() {
        context.dispatch({
          type: "ADD_RESOURCE",
          resourceHash: {
            [resourceId]: oldResource
          }
        });
      }
    });
  }
  remove() {
    let context = this._context;
    let internalResource = this._resource;
    let resourceId = internalResource.id;
    context.dispatch({
      type: "REMOVE_RESOURCE",
      resourceId
    });
    context.emitter.trigger("resourceRemove", {
      resource: this,
      revert() {
        context.dispatch({
          type: "ADD_RESOURCE",
          resourceHash: {
            [resourceId]: internalResource
          }
        });
      }
    });
  }
  getParent() {
    let context = this._context;
    let parentId = this._resource.parentId;
    if (parentId) {
      return new ResourceApi(context, context.getCurrentData().resourceStore[parentId]);
    }
    return null;
  }
  getChildren() {
    let thisResourceId = this._resource.id;
    let context = this._context;
    let { resourceStore } = context.getCurrentData();
    let childApis = [];
    for (let resourceId in resourceStore) {
      if (resourceStore[resourceId].parentId === thisResourceId) {
        childApis.push(new ResourceApi(context, resourceStore[resourceId]));
      }
    }
    return childApis;
  }
  /*
  this is really inefficient!
  TODO: make EventApi::resourceIds a hash or keep an index in the Calendar's state
  */
  getEvents() {
    let thisResourceId = this._resource.id;
    let context = this._context;
    let { defs: defs2, instances } = context.getCurrentData().eventStore;
    let eventApis = [];
    for (let instanceId in instances) {
      let instance = instances[instanceId];
      let def = defs2[instance.defId];
      if (def.resourceIds.indexOf(thisResourceId) !== -1) {
        eventApis.push(new EventImpl(context, def, instance));
      }
    }
    return eventApis;
  }
  get id() {
    return getPublicId(this._resource.id);
  }
  get title() {
    return this._resource.title;
  }
  get eventConstraint() {
    return this._resource.ui.constraints[0] || null;
  }
  // TODO: better type
  get eventOverlap() {
    return this._resource.ui.overlap;
  }
  get eventAllow() {
    return this._resource.ui.allows[0] || null;
  }
  // TODO: better type
  get eventBackgroundColor() {
    return this._resource.ui.backgroundColor;
  }
  get eventBorderColor() {
    return this._resource.ui.borderColor;
  }
  get eventTextColor() {
    return this._resource.ui.textColor;
  }
  // NOTE: user can't modify these because Object.freeze was called in event-def parsing
  get eventClassNames() {
    return this._resource.ui.classNames;
  }
  get extendedProps() {
    return this._resource.extendedProps;
  }
  toPlainObject(settings = {}) {
    let internal = this._resource;
    let { ui } = internal;
    let publicId = this.id;
    let res = {};
    if (publicId) {
      res.id = publicId;
    }
    if (internal.title) {
      res.title = internal.title;
    }
    if (settings.collapseEventColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
      res.eventColor = ui.backgroundColor;
    } else {
      if (ui.backgroundColor) {
        res.eventBackgroundColor = ui.backgroundColor;
      }
      if (ui.borderColor) {
        res.eventBorderColor = ui.borderColor;
      }
    }
    if (ui.textColor) {
      res.eventTextColor = ui.textColor;
    }
    if (ui.classNames.length) {
      res.eventClassNames = ui.classNames;
    }
    if (Object.keys(internal.extendedProps).length) {
      if (settings.collapseExtendedProps) {
        Object.assign(res, internal.extendedProps);
      } else {
        res.extendedProps = internal.extendedProps;
      }
    }
    return res;
  }
  toJSON() {
    return this.toPlainObject();
  }
};
function buildResourceApis(resourceStore, context) {
  let resourceApis = [];
  for (let resourceId in resourceStore) {
    resourceApis.push(new ResourceApi(context, resourceStore[resourceId]));
  }
  return resourceApis;
}
function refineRenderProps$1(input) {
  return {
    resource: new ResourceApi(input.context, input.resource)
  };
}
var DEFAULT_RESOURCE_ORDER = parseFieldSpecs("id,title");
function handleResourceStore(resourceStore, calendarData) {
  let { emitter } = calendarData;
  if (emitter.hasHandlers("resourcesSet")) {
    emitter.trigger("resourcesSet", buildResourceApis(resourceStore, calendarData));
  }
}
function buildRowNodes(resourceStore, groupSpecs, orderSpecs, isVGrouping, expansions, expansionDefault) {
  let complexNodes = buildHierarchy(resourceStore, isVGrouping ? -1 : 1, groupSpecs, orderSpecs);
  let flatNodes = [];
  flattenNodes(complexNodes, flatNodes, isVGrouping, [], 0, expansions, expansionDefault);
  return flatNodes;
}
function flattenNodes(complexNodes, res, isVGrouping, rowSpans, depth, expansions, expansionDefault) {
  for (let i = 0; i < complexNodes.length; i += 1) {
    let complexNode = complexNodes[i];
    let group = complexNode.group;
    if (group) {
      if (isVGrouping) {
        let firstRowIndex = res.length;
        let rowSpanIndex = rowSpans.length;
        flattenNodes(complexNode.children, res, isVGrouping, rowSpans.concat(0), depth, expansions, expansionDefault);
        if (firstRowIndex < res.length) {
          let firstRow = res[firstRowIndex];
          let firstRowSpans = firstRow.rowSpans = firstRow.rowSpans.slice();
          firstRowSpans[rowSpanIndex] = res.length - firstRowIndex;
        }
      } else {
        let id = group.spec.field + ":" + group.value;
        let isExpanded = expansions[id] != null ? expansions[id] : expansionDefault;
        res.push({ id, group, isExpanded });
        if (isExpanded) {
          flattenNodes(complexNode.children, res, isVGrouping, rowSpans, depth + 1, expansions, expansionDefault);
        }
      }
    } else if (complexNode.resource) {
      let id = complexNode.resource.id;
      let isExpanded = expansions[id] != null ? expansions[id] : expansionDefault;
      res.push({
        id,
        rowSpans,
        depth,
        isExpanded,
        hasChildren: Boolean(complexNode.children.length),
        resource: complexNode.resource,
        resourceFields: complexNode.resourceFields
      });
      if (isExpanded) {
        flattenNodes(complexNode.children, res, isVGrouping, rowSpans, depth + 1, expansions, expansionDefault);
      }
    }
  }
}
function buildHierarchy(resourceStore, maxDepth, groupSpecs, orderSpecs) {
  let resourceNodes = buildResourceNodes(resourceStore, orderSpecs);
  let builtNodes = [];
  for (let resourceId in resourceNodes) {
    let resourceNode = resourceNodes[resourceId];
    if (!resourceNode.resource.parentId) {
      insertResourceNode(resourceNode, builtNodes, groupSpecs, 0, maxDepth, orderSpecs);
    }
  }
  return builtNodes;
}
function buildResourceNodes(resourceStore, orderSpecs) {
  let nodeHash = {};
  for (let resourceId in resourceStore) {
    let resource = resourceStore[resourceId];
    nodeHash[resourceId] = {
      resource,
      resourceFields: buildResourceFields(resource),
      children: []
    };
  }
  for (let resourceId in resourceStore) {
    let resource = resourceStore[resourceId];
    if (resource.parentId) {
      let parentNode = nodeHash[resource.parentId];
      if (parentNode) {
        insertResourceNodeInSiblings(nodeHash[resourceId], parentNode.children, orderSpecs);
      }
    }
  }
  return nodeHash;
}
function insertResourceNode(resourceNode, nodes, groupSpecs, depth, maxDepth, orderSpecs) {
  if (groupSpecs.length && (maxDepth === -1 || depth <= maxDepth)) {
    let groupNode = ensureGroupNodes(resourceNode, nodes, groupSpecs[0]);
    insertResourceNode(resourceNode, groupNode.children, groupSpecs.slice(1), depth + 1, maxDepth, orderSpecs);
  } else {
    insertResourceNodeInSiblings(resourceNode, nodes, orderSpecs);
  }
}
function ensureGroupNodes(resourceNode, nodes, groupSpec) {
  let groupValue = resourceNode.resourceFields[groupSpec.field];
  let groupNode;
  let newGroupIndex;
  if (groupSpec.order) {
    for (newGroupIndex = 0; newGroupIndex < nodes.length; newGroupIndex += 1) {
      let node = nodes[newGroupIndex];
      if (node.group) {
        let cmp = flexibleCompare(groupValue, node.group.value) * groupSpec.order;
        if (cmp === 0) {
          groupNode = node;
          break;
        } else if (cmp < 0) {
          break;
        }
      }
    }
  } else {
    for (newGroupIndex = 0; newGroupIndex < nodes.length; newGroupIndex += 1) {
      let node = nodes[newGroupIndex];
      if (node.group && groupValue === node.group.value) {
        groupNode = node;
        break;
      }
    }
  }
  if (!groupNode) {
    groupNode = {
      group: {
        value: groupValue,
        spec: groupSpec
      },
      children: []
    };
    nodes.splice(newGroupIndex, 0, groupNode);
  }
  return groupNode;
}
function insertResourceNodeInSiblings(resourceNode, siblings, orderSpecs) {
  let i;
  for (i = 0; i < siblings.length; i += 1) {
    let cmp = compareByFieldSpecs(siblings[i].resourceFields, resourceNode.resourceFields, orderSpecs);
    if (cmp > 0) {
      break;
    }
  }
  siblings.splice(i, 0, resourceNode);
}
function buildResourceFields(resource) {
  let obj = Object.assign(Object.assign(Object.assign({}, resource.extendedProps), resource.ui), resource);
  delete obj.ui;
  delete obj.extendedProps;
  return obj;
}
function isGroupsEqual(group0, group1) {
  return group0.spec === group1.spec && group0.value === group1.value;
}
var ResourceSplitter = class extends Splitter {
  getKeyInfo(props) {
    return Object.assign({ "": {} }, props.resourceStore);
  }
  getKeysForDateSpan(dateSpan) {
    return [dateSpan.resourceId || ""];
  }
  getKeysForEventDef(eventDef) {
    let resourceIds = eventDef.resourceIds;
    if (!resourceIds.length) {
      return [""];
    }
    return resourceIds;
  }
};

// node_modules/@fullcalendar/resource/index.js
function massageEventDragMutation(eventMutation, hit0, hit1) {
  let resource0 = hit0.dateSpan.resourceId;
  let resource1 = hit1.dateSpan.resourceId;
  if (resource0 && resource1 && resource0 !== resource1) {
    eventMutation.resourceMutation = {
      matchResourceId: resource0,
      setResourceId: resource1
    };
  }
}
function applyEventDefMutation(eventDef, mutation, context) {
  let resourceMutation = mutation.resourceMutation;
  if (resourceMutation && computeResourceEditable(eventDef, context)) {
    let index5 = eventDef.resourceIds.indexOf(resourceMutation.matchResourceId);
    if (index5 !== -1) {
      let resourceIds = eventDef.resourceIds.slice();
      resourceIds.splice(index5, 1);
      if (resourceIds.indexOf(resourceMutation.setResourceId) === -1) {
        resourceIds.push(resourceMutation.setResourceId);
      }
      eventDef.resourceIds = resourceIds;
    }
  }
}
function computeResourceEditable(eventDef, context) {
  let { resourceEditable } = eventDef;
  if (resourceEditable == null) {
    let source = eventDef.sourceId && context.getCurrentData().eventSources[eventDef.sourceId];
    if (source) {
      resourceEditable = source.extendedProps.resourceEditable;
    }
    if (resourceEditable == null) {
      resourceEditable = context.options.eventResourceEditable;
      if (resourceEditable == null) {
        resourceEditable = context.options.editable;
      }
    }
  }
  return resourceEditable;
}
function transformEventDrop(mutation, context) {
  let { resourceMutation } = mutation;
  if (resourceMutation) {
    let { calendarApi } = context;
    return {
      oldResource: calendarApi.getResourceById(resourceMutation.matchResourceId),
      newResource: calendarApi.getResourceById(resourceMutation.setResourceId)
    };
  }
  return {
    oldResource: null,
    newResource: null
  };
}
var ResourceDataAdder = class {
  constructor() {
    this.filterResources = memoize(filterResources);
  }
  transform(viewProps, calendarProps) {
    if (calendarProps.viewSpec.optionDefaults.needsResourceData) {
      return {
        resourceStore: this.filterResources(calendarProps.resourceStore, calendarProps.options.filterResourcesWithEvents, calendarProps.eventStore, calendarProps.dateProfile.activeRange),
        resourceEntityExpansions: calendarProps.resourceEntityExpansions
      };
    }
    return null;
  }
};
function filterResources(resourceStore, doFilterResourcesWithEvents, eventStore, activeRange) {
  if (doFilterResourcesWithEvents) {
    let instancesInRange = filterEventInstancesInRange(eventStore.instances, activeRange);
    let hasEvents = computeHasEvents(instancesInRange, eventStore.defs);
    Object.assign(hasEvents, computeAncestorHasEvents(hasEvents, resourceStore));
    return filterHash(resourceStore, (resource, resourceId) => hasEvents[resourceId]);
  }
  return resourceStore;
}
function filterEventInstancesInRange(eventInstances, activeRange) {
  return filterHash(eventInstances, (eventInstance) => rangesIntersect(eventInstance.range, activeRange));
}
function computeHasEvents(eventInstances, eventDefs) {
  let hasEvents = {};
  for (let instanceId in eventInstances) {
    let instance = eventInstances[instanceId];
    for (let resourceId of eventDefs[instance.defId].resourceIds) {
      hasEvents[resourceId] = true;
    }
  }
  return hasEvents;
}
function computeAncestorHasEvents(hasEvents, resourceStore) {
  let res = {};
  for (let resourceId in hasEvents) {
    let resource;
    while (resource = resourceStore[resourceId]) {
      resourceId = resource.parentId;
      if (resourceId) {
        res[resourceId] = true;
      } else {
        break;
      }
    }
  }
  return res;
}
function transformIsDraggable(val, eventDef, eventUi, context) {
  if (!val) {
    let state = context.getCurrentData();
    let viewSpec = state.viewSpecs[state.currentViewType];
    if (viewSpec.optionDefaults.needsResourceData) {
      if (computeResourceEditable(eventDef, context)) {
        return true;
      }
    }
  }
  return val;
}
var ResourceEventConfigAdder = class {
  constructor() {
    this.buildResourceEventUis = memoize(buildResourceEventUis, isPropsEqual);
    this.injectResourceEventUis = memoize(injectResourceEventUis);
  }
  transform(viewProps, calendarProps) {
    if (!calendarProps.viewSpec.optionDefaults.needsResourceData) {
      return {
        eventUiBases: this.injectResourceEventUis(viewProps.eventUiBases, viewProps.eventStore.defs, this.buildResourceEventUis(calendarProps.resourceStore))
      };
    }
    return null;
  }
};
function buildResourceEventUis(resourceStore) {
  return mapHash(resourceStore, (resource) => resource.ui);
}
function injectResourceEventUis(eventUiBases, eventDefs, resourceEventUis) {
  return mapHash(eventUiBases, (eventUi, defId) => {
    if (defId) {
      return injectResourceEventUi(eventUi, eventDefs[defId], resourceEventUis);
    }
    return eventUi;
  });
}
function injectResourceEventUi(origEventUi, eventDef, resourceEventUis) {
  let parts = [];
  for (let resourceId of eventDef.resourceIds) {
    if (resourceEventUis[resourceId]) {
      parts.unshift(resourceEventUis[resourceId]);
    }
  }
  parts.unshift(origEventUi);
  return combineEventUis(parts);
}
var defs = [];
function registerResourceSourceDef(def) {
  defs.push(def);
}
function getResourceSourceDef(id) {
  return defs[id];
}
function getResourceSourceDefs() {
  return defs;
}
var RESOURCE_SOURCE_REFINERS = {
  id: String,
  // for array. TODO: move to resource-array
  resources: identity,
  // for json feed. TODO: move to resource-json-feed
  url: String,
  method: String,
  startParam: String,
  endParam: String,
  timeZoneParam: String,
  extraParams: identity
};
function parseResourceSource(input) {
  let inputObj;
  if (typeof input === "string") {
    inputObj = { url: input };
  } else if (typeof input === "function" || Array.isArray(input)) {
    inputObj = { resources: input };
  } else if (typeof input === "object" && input) {
    inputObj = input;
  }
  if (inputObj) {
    let { refined, extra } = refineProps(inputObj, RESOURCE_SOURCE_REFINERS);
    warnUnknownProps(extra);
    let metaRes = buildResourceSourceMeta(refined);
    if (metaRes) {
      return {
        _raw: input,
        sourceId: guid(),
        sourceDefId: metaRes.sourceDefId,
        meta: metaRes.meta,
        publicId: refined.id || "",
        isFetching: false,
        latestFetchId: "",
        fetchRange: null
      };
    }
  }
  return null;
}
function buildResourceSourceMeta(refined) {
  let defs2 = getResourceSourceDefs();
  for (let i = defs2.length - 1; i >= 0; i -= 1) {
    let def = defs2[i];
    let meta = def.parseMeta(refined);
    if (meta) {
      return { meta, sourceDefId: i };
    }
  }
  return null;
}
function warnUnknownProps(props) {
  for (let propName in props) {
    console.warn(`Unknown resource prop '${propName}'`);
  }
}
function reduceResourceSource(source, action, context) {
  let { options, dateProfile } = context;
  if (!source || !action) {
    return createSource(options.initialResources || options.resources, dateProfile.activeRange, options.refetchResourcesOnNavigate, context);
  }
  switch (action.type) {
    case "RESET_RESOURCE_SOURCE":
      return createSource(action.resourceSourceInput, dateProfile.activeRange, options.refetchResourcesOnNavigate, context);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      return handleRangeChange(source, dateProfile.activeRange, options.refetchResourcesOnNavigate, context);
    case "RECEIVE_RESOURCES":
    case "RECEIVE_RESOURCE_ERROR":
      return receiveResponse(source, action.fetchId, action.fetchRange);
    case "REFETCH_RESOURCES":
      return fetchSource(source, dateProfile.activeRange, context);
    default:
      return source;
  }
}
function createSource(input, activeRange, refetchResourcesOnNavigate, context) {
  if (input) {
    let source = parseResourceSource(input);
    source = fetchSource(source, refetchResourcesOnNavigate ? activeRange : null, context);
    return source;
  }
  return null;
}
function handleRangeChange(source, activeRange, refetchResourcesOnNavigate, context) {
  if (refetchResourcesOnNavigate && !doesSourceIgnoreRange(source) && (!source.fetchRange || !rangesEqual(source.fetchRange, activeRange))) {
    return fetchSource(source, activeRange, context);
  }
  return source;
}
function doesSourceIgnoreRange(source) {
  return Boolean(getResourceSourceDef(source.sourceDefId).ignoreRange);
}
function fetchSource(source, fetchRange, context) {
  let sourceDef = getResourceSourceDef(source.sourceDefId);
  let fetchId = guid();
  sourceDef.fetch({
    resourceSource: source,
    range: fetchRange,
    context
  }, (res) => {
    context.dispatch({
      type: "RECEIVE_RESOURCES",
      fetchId,
      fetchRange,
      rawResources: res.rawResources
    });
  }, (error) => {
    context.dispatch({
      type: "RECEIVE_RESOURCE_ERROR",
      fetchId,
      fetchRange,
      error
    });
  });
  return Object.assign(Object.assign({}, source), { isFetching: true, latestFetchId: fetchId });
}
function receiveResponse(source, fetchId, fetchRange) {
  if (fetchId === source.latestFetchId) {
    return Object.assign(Object.assign({}, source), { isFetching: false, fetchRange });
  }
  return source;
}
function reduceResourceStore(store, action, source, context) {
  if (!store || !action) {
    return {};
  }
  switch (action.type) {
    case "RECEIVE_RESOURCES":
      return receiveRawResources(store, action.rawResources, action.fetchId, source, context);
    case "ADD_RESOURCE":
      return addResource(store, action.resourceHash);
    case "REMOVE_RESOURCE":
      return removeResource(store, action.resourceId);
    case "SET_RESOURCE_PROP":
      return setResourceProp(store, action.resourceId, action.propName, action.propValue);
    case "SET_RESOURCE_EXTENDED_PROP":
      return setResourceExtendedProp(store, action.resourceId, action.propName, action.propValue);
    default:
      return store;
  }
}
function receiveRawResources(existingStore, inputs, fetchId, source, context) {
  if (source.latestFetchId === fetchId) {
    let nextStore = {};
    for (let input of inputs) {
      parseResource(input, "", nextStore, context);
    }
    return nextStore;
  }
  return existingStore;
}
function addResource(existingStore, additions) {
  return Object.assign(Object.assign({}, existingStore), additions);
}
function removeResource(existingStore, resourceId) {
  let newStore = Object.assign({}, existingStore);
  delete newStore[resourceId];
  for (let childResourceId in newStore) {
    if (newStore[childResourceId].parentId === resourceId) {
      newStore[childResourceId] = Object.assign(Object.assign({}, newStore[childResourceId]), { parentId: "" });
    }
  }
  return newStore;
}
function setResourceProp(existingStore, resourceId, name, value) {
  let existingResource = existingStore[resourceId];
  if (existingResource) {
    return Object.assign(Object.assign({}, existingStore), { [resourceId]: Object.assign(Object.assign({}, existingResource), { [name]: value }) });
  }
  return existingStore;
}
function setResourceExtendedProp(existingStore, resourceId, name, value) {
  let existingResource = existingStore[resourceId];
  if (existingResource) {
    return Object.assign(Object.assign({}, existingStore), { [resourceId]: Object.assign(Object.assign({}, existingResource), { extendedProps: Object.assign(Object.assign({}, existingResource.extendedProps), { [name]: value }) }) });
  }
  return existingStore;
}
function reduceResourceEntityExpansions(expansions, action) {
  if (!expansions || !action) {
    return {};
  }
  switch (action.type) {
    case "SET_RESOURCE_ENTITY_EXPANDED":
      return Object.assign(Object.assign({}, expansions), { [action.id]: action.isExpanded });
    default:
      return expansions;
  }
}
function reduceResources(state, action, context) {
  let resourceSource = reduceResourceSource(state && state.resourceSource, action, context);
  let resourceStore = reduceResourceStore(state && state.resourceStore, action, resourceSource, context);
  let resourceEntityExpansions = reduceResourceEntityExpansions(state && state.resourceEntityExpansions, action);
  return {
    resourceSource,
    resourceStore,
    resourceEntityExpansions
  };
}
var EVENT_REFINERS = {
  resourceId: String,
  resourceIds: identity,
  resourceEditable: Boolean
};
function generateEventDefResourceMembers(refined) {
  return {
    resourceIds: ensureStringArray(refined.resourceIds).concat(refined.resourceId ? [refined.resourceId] : []),
    resourceEditable: refined.resourceEditable
  };
}
function ensureStringArray(items) {
  return (items || []).map((item) => String(item));
}
function transformDateSelectionJoin(hit0, hit1) {
  let resourceId0 = hit0.dateSpan.resourceId;
  let resourceId1 = hit1.dateSpan.resourceId;
  if (resourceId0 && resourceId1) {
    return { resourceId: resourceId0 };
  }
  return null;
}
CalendarImpl.prototype.addResource = function(input, scrollTo = true) {
  let currentState = this.getCurrentData();
  let resourceHash;
  let resource;
  if (input instanceof ResourceApi) {
    resource = input._resource;
    resourceHash = { [resource.id]: resource };
  } else {
    resourceHash = {};
    resource = parseResource(input, "", resourceHash, currentState);
  }
  this.dispatch({
    type: "ADD_RESOURCE",
    resourceHash
  });
  if (scrollTo) {
    this.trigger("_scrollRequest", { resourceId: resource.id });
  }
  let resourceApi = new ResourceApi(currentState, resource);
  currentState.emitter.trigger("resourceAdd", {
    resource: resourceApi,
    revert: () => {
      this.dispatch({
        type: "REMOVE_RESOURCE",
        resourceId: resource.id
      });
    }
  });
  return resourceApi;
};
CalendarImpl.prototype.getResourceById = function(id) {
  id = String(id);
  let currentState = this.getCurrentData();
  if (currentState.resourceStore) {
    let rawResource = currentState.resourceStore[id];
    if (rawResource) {
      return new ResourceApi(currentState, rawResource);
    }
  }
  return null;
};
CalendarImpl.prototype.getResources = function() {
  let currentState = this.getCurrentData();
  let { resourceStore } = currentState;
  let resourceApis = [];
  if (resourceStore) {
    for (let resourceId in resourceStore) {
      resourceApis.push(new ResourceApi(currentState, resourceStore[resourceId]));
    }
  }
  return resourceApis;
};
CalendarImpl.prototype.getTopLevelResources = function() {
  let currentState = this.getCurrentData();
  let { resourceStore } = currentState;
  let resourceApis = [];
  if (resourceStore) {
    for (let resourceId in resourceStore) {
      if (!resourceStore[resourceId].parentId) {
        resourceApis.push(new ResourceApi(currentState, resourceStore[resourceId]));
      }
    }
  }
  return resourceApis;
};
CalendarImpl.prototype.refetchResources = function() {
  this.dispatch({
    type: "REFETCH_RESOURCES"
  });
};
function transformDatePoint(dateSpan, context) {
  return dateSpan.resourceId ? { resource: context.calendarApi.getResourceById(dateSpan.resourceId) } : {};
}
function transformDateSpan(dateSpan, context) {
  return dateSpan.resourceId ? { resource: context.calendarApi.getResourceById(dateSpan.resourceId) } : {};
}
function isPropsValidWithResources(combinedProps, context) {
  let splitter = new ResourceSplitter();
  let sets = splitter.splitProps(Object.assign(Object.assign({}, combinedProps), { resourceStore: context.getCurrentData().resourceStore }));
  for (let resourceId in sets) {
    let props = sets[resourceId];
    if (resourceId && sets[""]) {
      props = Object.assign(Object.assign({}, props), { eventStore: mergeEventStores(sets[""].eventStore, props.eventStore), eventUiBases: Object.assign(Object.assign({}, sets[""].eventUiBases), props.eventUiBases) });
    }
    if (!isPropsValid(props, context, { resourceId }, filterConfig.bind(null, resourceId))) {
      return false;
    }
  }
  return true;
}
function filterConfig(resourceId, config2) {
  return Object.assign(Object.assign({}, config2), { constraints: filterConstraints(resourceId, config2.constraints) });
}
function filterConstraints(resourceId, constraints) {
  return constraints.map((constraint) => {
    let defs2 = constraint.defs;
    if (defs2) {
      for (let defId in defs2) {
        let resourceIds = defs2[defId].resourceIds;
        if (resourceIds.length && resourceIds.indexOf(resourceId) === -1) {
          return false;
        }
      }
    }
    return constraint;
  });
}
function transformExternalDef(dateSpan) {
  return dateSpan.resourceId ? { resourceId: dateSpan.resourceId } : {};
}
var optionChangeHandlers = {
  resources: handleResources
};
function handleResources(newSourceInput, context) {
  let oldSourceInput = context.getCurrentData().resourceSource._raw;
  if (oldSourceInput !== newSourceInput) {
    context.dispatch({
      type: "RESET_RESOURCE_SOURCE",
      resourceSourceInput: newSourceInput
    });
  }
}
var OPTION_REFINERS = {
  initialResources: identity,
  resources: identity,
  eventResourceEditable: Boolean,
  refetchResourcesOnNavigate: Boolean,
  resourceOrder: parseFieldSpecs,
  filterResourcesWithEvents: Boolean,
  resourceGroupField: String,
  resourceAreaWidth: identity,
  resourceAreaColumns: identity,
  resourcesInitiallyExpanded: Boolean,
  datesAboveResources: Boolean,
  needsResourceData: Boolean,
  resourceAreaHeaderClassNames: identity,
  resourceAreaHeaderContent: identity,
  resourceAreaHeaderDidMount: identity,
  resourceAreaHeaderWillUnmount: identity,
  resourceGroupLabelClassNames: identity,
  resourceGroupLabelContent: identity,
  resourceGroupLabelDidMount: identity,
  resourceGroupLabelWillUnmount: identity,
  resourceLabelClassNames: identity,
  resourceLabelContent: identity,
  resourceLabelDidMount: identity,
  resourceLabelWillUnmount: identity,
  resourceLaneClassNames: identity,
  resourceLaneContent: identity,
  resourceLaneDidMount: identity,
  resourceLaneWillUnmount: identity,
  resourceGroupLaneClassNames: identity,
  resourceGroupLaneContent: identity,
  resourceGroupLaneDidMount: identity,
  resourceGroupLaneWillUnmount: identity
};
var LISTENER_REFINERS = {
  resourcesSet: identity,
  resourceAdd: identity,
  resourceChange: identity,
  resourceRemove: identity
};
EventImpl.prototype.getResources = function() {
  let { calendarApi } = this._context;
  return this._def.resourceIds.map((resourceId) => calendarApi.getResourceById(resourceId));
};
EventImpl.prototype.setResources = function(resources) {
  let resourceIds = [];
  for (let resource of resources) {
    let resourceId = null;
    if (typeof resource === "string") {
      resourceId = resource;
    } else if (typeof resource === "number") {
      resourceId = String(resource);
    } else if (resource instanceof ResourceApi) {
      resourceId = resource.id;
    } else {
      console.warn("unknown resource type: " + resource);
    }
    if (resourceId) {
      resourceIds.push(resourceId);
    }
  }
  this.mutate({
    standardProps: {
      resourceIds
    }
  });
};
registerResourceSourceDef({
  ignoreRange: true,
  parseMeta(refined) {
    if (Array.isArray(refined.resources)) {
      return refined.resources;
    }
    return null;
  },
  fetch(arg, successCallback) {
    successCallback({
      rawResources: arg.resourceSource.meta
    });
  }
});
registerResourceSourceDef({
  parseMeta(refined) {
    if (typeof refined.resources === "function") {
      return refined.resources;
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const dateEnv = arg.context.dateEnv;
    const func = arg.resourceSource.meta;
    const publicArg = arg.range ? {
      start: dateEnv.toDate(arg.range.start),
      end: dateEnv.toDate(arg.range.end),
      startStr: dateEnv.formatIso(arg.range.start),
      endStr: dateEnv.formatIso(arg.range.end),
      timeZone: dateEnv.timeZone
    } : {};
    unpromisify(func.bind(null, publicArg), (rawResources) => successCallback({ rawResources }), errorCallback);
  }
});
registerResourceSourceDef({
  parseMeta(refined) {
    if (refined.url) {
      return {
        url: refined.url,
        method: (refined.method || "GET").toUpperCase(),
        extraParams: refined.extraParams
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const meta = arg.resourceSource.meta;
    const requestParams = buildRequestParams(meta, arg.range, arg.context);
    requestJson(meta.method, meta.url, requestParams).then(([rawResources, response]) => {
      successCallback({ rawResources, response });
    }, errorCallback);
  }
});
function buildRequestParams(meta, range, context) {
  let { dateEnv, options } = context;
  let startParam;
  let endParam;
  let timeZoneParam;
  let customRequestParams;
  let params = {};
  if (range) {
    startParam = meta.startParam;
    if (startParam == null) {
      startParam = options.startParam;
    }
    endParam = meta.endParam;
    if (endParam == null) {
      endParam = options.endParam;
    }
    timeZoneParam = meta.timeZoneParam;
    if (timeZoneParam == null) {
      timeZoneParam = options.timeZoneParam;
    }
    params[startParam] = dateEnv.formatIso(range.start);
    params[endParam] = dateEnv.formatIso(range.end);
    if (dateEnv.timeZone !== "local") {
      params[timeZoneParam] = dateEnv.timeZone;
    }
  }
  if (typeof meta.extraParams === "function") {
    customRequestParams = meta.extraParams();
  } else {
    customRequestParams = meta.extraParams || {};
  }
  Object.assign(params, customRequestParams);
  return params;
}
var index3 = createPlugin({
  name: "@fullcalendar/resource",
  premiumReleaseDate: "2023-05-25",
  deps: [index],
  reducers: [reduceResources],
  isLoadingFuncs: [
    (state) => state.resourceSource && state.resourceSource.isFetching
  ],
  eventRefiners: EVENT_REFINERS,
  eventDefMemberAdders: [generateEventDefResourceMembers],
  isDraggableTransformers: [transformIsDraggable],
  eventDragMutationMassagers: [massageEventDragMutation],
  eventDefMutationAppliers: [applyEventDefMutation],
  dateSelectionTransformers: [transformDateSelectionJoin],
  datePointTransforms: [transformDatePoint],
  dateSpanTransforms: [transformDateSpan],
  viewPropsTransformers: [ResourceDataAdder, ResourceEventConfigAdder],
  isPropsValid: isPropsValidWithResources,
  externalDefTransforms: [transformExternalDef],
  eventDropTransformers: [transformEventDrop],
  optionChangeHandlers,
  optionRefiners: OPTION_REFINERS,
  listenerRefiners: LISTENER_REFINERS,
  propSetHandlers: { resourceStore: handleResourceStore }
});

// node_modules/@fullcalendar/resource-timeline/internal.js
var css_248z = ".fc .fc-resource-timeline-divider{cursor:col-resize;width:3px}.fc .fc-resource-group{font-weight:inherit;text-align:inherit}.fc .fc-resource-timeline .fc-resource-group:not([rowspan]){background:var(--fc-neutral-bg-color)}.fc .fc-timeline-lane-frame{position:relative}.fc .fc-timeline-overlap-enabled .fc-timeline-lane-frame .fc-timeline-events{box-sizing:content-box;padding-bottom:10px}.fc-timeline-body-expandrows td.fc-timeline-lane{position:relative}.fc-timeline-body-expandrows .fc-timeline-lane-frame{position:static}.fc-datagrid-cell-frame-liquid{height:100%}.fc-liquid-hack .fc-datagrid-cell-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-datagrid-header .fc-datagrid-cell-frame{align-items:center;display:flex;justify-content:flex-start;position:relative}.fc .fc-datagrid-cell-resizer{bottom:0;cursor:col-resize;position:absolute;top:0;width:5px;z-index:1}.fc .fc-datagrid-cell-cushion{overflow:hidden;padding:8px;white-space:nowrap}.fc .fc-datagrid-expander{cursor:pointer;opacity:.65}.fc .fc-datagrid-expander .fc-icon{display:inline-block;width:1em}.fc .fc-datagrid-expander-placeholder{cursor:auto}.fc .fc-resource-timeline-flat .fc-datagrid-expander-placeholder{display:none}.fc-direction-ltr .fc-datagrid-cell-resizer{right:-3px}.fc-direction-rtl .fc-datagrid-cell-resizer{left:-3px}.fc-direction-ltr .fc-datagrid-expander{margin-right:3px}.fc-direction-rtl .fc-datagrid-expander{margin-left:3px}";
injectStyles(css_248z);
function ExpanderIcon({ depth, hasChildren, isExpanded, onExpanderClick }) {
  let nodes = [];
  for (let i = 0; i < depth; i += 1) {
    nodes.push(y("span", { className: "fc-icon" }));
  }
  let iconClassNames = ["fc-icon"];
  if (hasChildren) {
    if (isExpanded) {
      iconClassNames.push("fc-icon-minus-square");
    } else {
      iconClassNames.push("fc-icon-plus-square");
    }
  }
  nodes.push(y(
    "span",
    { className: "fc-datagrid-expander" + (hasChildren ? "" : " fc-datagrid-expander-placeholder"), onClick: onExpanderClick },
    y("span", { className: iconClassNames.join(" ") })
  ));
  return y(_, {}, ...nodes);
}
var SpreadsheetIndividualCell = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps);
    this.onExpanderClick = (ev) => {
      let { props } = this;
      if (props.hasChildren) {
        this.context.dispatch({
          type: "SET_RESOURCE_ENTITY_EXPANDED",
          id: props.resource.id,
          isExpanded: !props.isExpanded
        });
      }
    };
  }
  render() {
    let { props, context } = this;
    let { colSpec } = props;
    let renderProps = this.refineRenderProps({
      resource: props.resource,
      fieldValue: props.fieldValue,
      context
    });
    return y(ContentContainer, { elTag: "td", elClasses: [
      "fc-datagrid-cell",
      "fc-resource"
    ], elAttrs: {
      role: "gridcell",
      "data-resource-id": props.resource.id
    }, renderProps, generatorName: colSpec.isMain ? "resourceLabelContent" : void 0, customGenerator: colSpec.cellContent, defaultGenerator: renderResourceInner, classNameGenerator: colSpec.cellClassNames, didMount: colSpec.cellDidMount, willUnmount: colSpec.cellWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-datagrid-cell-frame", style: { height: props.innerHeight } },
      y(
        "div",
        { className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner" },
        colSpec.isMain && y(ExpanderIcon, { depth: props.depth, hasChildren: props.hasChildren, isExpanded: props.isExpanded, onExpanderClick: this.onExpanderClick }),
        y(InnerContent, { elTag: "span", elClasses: ["fc-datagrid-cell-main"] })
      )
    ));
  }
};
function renderResourceInner(renderProps) {
  return renderProps.fieldValue || y(_, null, " ");
}
function refineRenderProps(input) {
  return {
    resource: new ResourceApi(input.context, input.resource),
    fieldValue: input.fieldValue,
    view: input.context.viewApi
  };
}
var SpreadsheetGroupCell = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { colSpec } = props;
    let renderProps = {
      groupValue: props.fieldValue,
      view: context.viewApi
    };
    return y(ContentContainer, { elTag: "td", elClasses: [
      "fc-datagrid-cell",
      "fc-resource-group"
    ], elAttrs: {
      role: "gridcell",
      rowSpan: props.rowSpan
    }, renderProps, generatorName: "resourceGroupLabelContent", customGenerator: colSpec.cellContent, defaultGenerator: renderGroupInner, classNameGenerator: colSpec.cellClassNames, didMount: colSpec.cellDidMount, willUnmount: colSpec.cellWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-datagrid-cell-frame fc-datagrid-cell-frame-liquid" },
      y(InnerContent, { elTag: "div", elClasses: ["fc-datagrid-cell-cushion", "fc-sticky"] })
    ));
  }
};
function renderGroupInner(renderProps) {
  return renderProps.groupValue || y(_, null, " ");
}
var SpreadsheetRow = class extends BaseComponent {
  render() {
    let { props } = this;
    let { resource, rowSpans, depth } = props;
    let resourceFields = buildResourceFields(resource);
    return y("tr", { role: "row" }, props.colSpecs.map((colSpec, i) => {
      let rowSpan = rowSpans[i];
      if (rowSpan === 0) {
        return null;
      }
      if (rowSpan == null) {
        rowSpan = 1;
      }
      let fieldValue = colSpec.field ? resourceFields[colSpec.field] : resource.title || getPublicId(resource.id);
      if (rowSpan > 1) {
        return y(SpreadsheetGroupCell, { key: i, colSpec, fieldValue, rowSpan });
      }
      return y(SpreadsheetIndividualCell, { key: i, colSpec, resource, fieldValue, depth, hasChildren: props.hasChildren, isExpanded: props.isExpanded, innerHeight: props.innerHeight });
    }));
  }
};
SpreadsheetRow.addPropsEquality({
  rowSpans: isArraysEqual
});
var SpreadsheetGroupRow = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.innerInnerRef = d();
    this.onExpanderClick = () => {
      let { props } = this;
      this.context.dispatch({
        type: "SET_RESOURCE_ENTITY_EXPANDED",
        id: props.id,
        isExpanded: !props.isExpanded
      });
    };
  }
  render() {
    let { props, context } = this;
    let renderProps = { groupValue: props.group.value, view: context.viewApi };
    let spec = props.group.spec;
    return y(
      "tr",
      { role: "row" },
      y(ContentContainer, { elTag: "th", elClasses: [
        "fc-datagrid-cell",
        "fc-resource-group",
        context.theme.getClass("tableCellShaded")
      ], elAttrs: {
        // ARIA TODO: not really a columnheader
        // extremely tedious to make this aria-compliant,
        // to assign multiple headers to each cell
        // https://www.w3.org/WAI/tutorials/tables/multi-level/
        role: "columnheader",
        scope: "colgroup",
        colSpan: props.spreadsheetColCnt
      }, renderProps, generatorName: "resourceGroupLabelContent", customGenerator: spec.labelContent, defaultGenerator: renderCellInner, classNameGenerator: spec.labelClassNames, didMount: spec.labelDidMount, willUnmount: spec.labelWillUnmount }, (InnerContent) => y(
        "div",
        { className: "fc-datagrid-cell-frame", style: { height: props.innerHeight } },
        y(
          "div",
          { className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner", ref: this.innerInnerRef },
          y(ExpanderIcon, { depth: 0, hasChildren: true, isExpanded: props.isExpanded, onExpanderClick: this.onExpanderClick }),
          y(InnerContent, { elTag: "span", elClasses: ["fc-datagrid-cell-main"] })
        )
      ))
    );
  }
};
SpreadsheetGroupRow.addPropsEquality({
  group: isGroupsEqual
});
function renderCellInner(renderProps) {
  return renderProps.groupValue || y(_, null, " ");
}
var SPREADSHEET_COL_MIN_WIDTH = 20;
var SpreadsheetHeader = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.resizerElRefs = new RefMap(this._handleColResizerEl.bind(this));
    this.colDraggings = {};
  }
  render() {
    let { colSpecs, superHeaderRendering, rowInnerHeights } = this.props;
    let renderProps = { view: this.context.viewApi };
    let rowNodes = [];
    rowInnerHeights = rowInnerHeights.slice();
    if (superHeaderRendering) {
      let rowInnerHeight2 = rowInnerHeights.shift();
      rowNodes.push(y(
        "tr",
        { key: "row-super", role: "row" },
        y(ContentContainer, { elTag: "th", elClasses: [
          "fc-datagrid-cell",
          "fc-datagrid-cell-super"
        ], elAttrs: {
          role: "columnheader",
          scope: "colgroup",
          colSpan: colSpecs.length
        }, renderProps, generatorName: "resourceAreaHeaderContent", customGenerator: superHeaderRendering.headerContent, defaultGenerator: superHeaderRendering.headerDefault, classNameGenerator: superHeaderRendering.headerClassNames, didMount: superHeaderRendering.headerDidMount, willUnmount: superHeaderRendering.headerWillUnmount }, (InnerContent) => y(
          "div",
          { className: "fc-datagrid-cell-frame", style: { height: rowInnerHeight2 } },
          y(InnerContent, { elTag: "div", elClasses: ["fc-datagrid-cell-cushion", "fc-scrollgrid-sync-inner"] })
        ))
      ));
    }
    let rowInnerHeight = rowInnerHeights.shift();
    rowNodes.push(y("tr", { key: "row", role: "row" }, colSpecs.map((colSpec, i) => {
      let isLastCol = i === colSpecs.length - 1;
      return y(ContentContainer, { key: i, elTag: "th", elClasses: ["fc-datagrid-cell"], elAttrs: { role: "columnheader" }, renderProps, generatorName: "resourceAreaHeaderContent", customGenerator: colSpec.headerContent, defaultGenerator: colSpec.headerDefault, classNameGenerator: colSpec.headerClassNames, didMount: colSpec.headerDidMount, willUnmount: colSpec.headerWillUnmount }, (InnerContent) => y(
        "div",
        { className: "fc-datagrid-cell-frame", style: { height: rowInnerHeight } },
        y(
          "div",
          { className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner" },
          colSpec.isMain && y(
            "span",
            { className: "fc-datagrid-expander fc-datagrid-expander-placeholder" },
            y("span", { className: "fc-icon" })
          ),
          y(InnerContent, { elTag: "span", elClasses: ["fc-datagrid-cell-main"] })
        ),
        !isLastCol && y("div", { className: "fc-datagrid-cell-resizer", ref: this.resizerElRefs.createRef(i) })
      ));
    })));
    return y(_, null, rowNodes);
  }
  _handleColResizerEl(resizerEl, index5) {
    let { colDraggings } = this;
    if (!resizerEl) {
      let dragging = colDraggings[index5];
      if (dragging) {
        dragging.destroy();
        delete colDraggings[index5];
      }
    } else {
      let dragging = this.initColResizing(resizerEl, parseInt(index5, 10));
      if (dragging) {
        colDraggings[index5] = dragging;
      }
    }
  }
  initColResizing(resizerEl, index5) {
    let { pluginHooks, isRtl } = this.context;
    let { onColWidthChange } = this.props;
    let ElementDraggingImpl = pluginHooks.elementDraggingImpl;
    if (ElementDraggingImpl) {
      let dragging = new ElementDraggingImpl(resizerEl);
      let startWidth;
      let currentWidths;
      dragging.emitter.on("dragstart", () => {
        let allCells = findElements(elementClosest(resizerEl, "tr"), "th");
        currentWidths = allCells.map((cellEl) => cellEl.getBoundingClientRect().width);
        startWidth = currentWidths[index5];
      });
      dragging.emitter.on("dragmove", (pev) => {
        currentWidths[index5] = Math.max(startWidth + pev.deltaX * (isRtl ? -1 : 1), SPREADSHEET_COL_MIN_WIDTH);
        if (onColWidthChange) {
          onColWidthChange(currentWidths.slice());
        }
      });
      dragging.setAutoScrollEnabled(false);
      return dragging;
    }
    return null;
  }
};
var ResourceTimelineLane = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps$1);
    this.handleHeightChange = (innerEl, isStable) => {
      if (this.props.onHeightChange) {
        this.props.onHeightChange(
          // would want to use own <tr> ref, but not guaranteed to be ready when this fires
          elementClosest(innerEl, "tr"),
          isStable
        );
      }
    };
  }
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = this.refineRenderProps({ resource: props.resource, context });
    return y(
      "tr",
      { ref: props.elRef },
      y(ContentContainer, { elTag: "td", elClasses: [
        "fc-timeline-lane",
        "fc-resource"
      ], elAttrs: {
        "data-resource-id": props.resource.id
      }, renderProps, generatorName: "resourceLaneContent", customGenerator: options.resourceLaneContent, classNameGenerator: options.resourceLaneClassNames, didMount: options.resourceLaneDidMount, willUnmount: options.resourceLaneWillUnmount }, (InnerContent) => y(
        "div",
        { className: "fc-timeline-lane-frame", style: { height: props.innerHeight } },
        y(InnerContent, { elTag: "div", elClasses: ["fc-timeline-lane-misc"] }),
        y(TimelineLane, { dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, nextDayThreshold: props.nextDayThreshold, businessHours: props.businessHours, eventStore: props.eventStore, eventUiBases: props.eventUiBases, dateSelection: props.dateSelection, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, timelineCoords: props.timelineCoords, onHeightChange: this.handleHeightChange, resourceId: props.resource.id })
      ))
    );
  }
};
var DividerRow = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { renderHooks } = props;
    let renderProps = {
      groupValue: props.groupValue,
      view: context.viewApi
    };
    return y(
      "tr",
      { ref: props.elRef },
      y(ContentContainer, { elTag: "td", elRef: props.elRef, elClasses: [
        "fc-timeline-lane",
        "fc-resource-group",
        context.theme.getClass("tableCellShaded")
      ], renderProps, generatorName: "resourceGroupLaneContent", customGenerator: renderHooks.laneContent, classNameGenerator: renderHooks.laneClassNames, didMount: renderHooks.laneDidMount, willUnmount: renderHooks.laneWillUnmount }, (InnerContainer) => y(InnerContainer, { elTag: "div", elStyle: { height: props.innerHeight } }))
    );
  }
};
var ResourceTimelineLanesBody = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { rowElRefs, innerHeights } = props;
    return y("tbody", null, props.rowNodes.map((node, index5) => {
      if (node.group) {
        return y(DividerRow, { key: node.id, elRef: rowElRefs.createRef(node.id), groupValue: node.group.value, renderHooks: node.group.spec, innerHeight: innerHeights[index5] || "" });
      }
      if (node.resource) {
        let resource = node.resource;
        return y(ResourceTimelineLane, Object.assign({ key: node.id, elRef: rowElRefs.createRef(node.id) }, props.splitProps[resource.id], { resource, dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, nextDayThreshold: context.options.nextDayThreshold, businessHours: resource.businessHours || props.fallbackBusinessHours, innerHeight: innerHeights[index5] || "", timelineCoords: props.slatCoords, onHeightChange: props.onRowHeightChange }));
      }
      return null;
    }));
  }
};
var ResourceTimelineLanes = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.rowElRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    return y(
      "table",
      { ref: this.rootElRef, "aria-hidden": true, className: "fc-scrollgrid-sync-table " + context.theme.getClass("table"), style: {
        minWidth: props.tableMinWidth,
        width: props.clientWidth,
        height: props.minHeight
      } },
      y(ResourceTimelineLanesBody, { rowElRefs: this.rowElRefs, rowNodes: props.rowNodes, dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, splitProps: props.splitProps, fallbackBusinessHours: props.fallbackBusinessHours, slatCoords: props.slatCoords, innerHeights: props.innerHeights, onRowHeightChange: props.onRowHeightChange })
    );
  }
  componentDidMount() {
    this.updateCoords();
  }
  componentDidUpdate() {
    this.updateCoords();
  }
  componentWillUnmount() {
    if (this.props.onRowCoords) {
      this.props.onRowCoords(null);
    }
  }
  updateCoords() {
    let { props } = this;
    if (props.onRowCoords && props.clientWidth !== null) {
      this.props.onRowCoords(new PositionCache(this.rootElRef.current, collectRowEls(this.rowElRefs.currentMap, props.rowNodes), false, true));
    }
  }
};
function collectRowEls(elMap, rowNodes) {
  return rowNodes.map((rowNode) => elMap[rowNode.id]);
}
var ResourceTimelineGrid = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.computeHasResourceBusinessHours = memoize(computeHasResourceBusinessHours);
    this.resourceSplitter = new ResourceSplitter();
    this.bgSlicer = new TimelineLaneSlicer();
    this.slatsRef = d();
    this.state = {
      slatCoords: null
    };
    this.handleEl = (el) => {
      if (el) {
        this.context.registerInteractiveComponent(this, { el });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
      if (this.props.onSlatCoords) {
        this.props.onSlatCoords(slatCoords);
      }
    };
    this.handleRowCoords = (rowCoords) => {
      this.rowCoords = rowCoords;
      if (this.props.onRowCoords) {
        this.props.onRowCoords(rowCoords);
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { dateProfile, tDateProfile } = props;
    let timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;
    let hasResourceBusinessHours = this.computeHasResourceBusinessHours(props.rowNodes);
    let splitProps = this.resourceSplitter.splitProps(props);
    let bgLaneProps = splitProps[""];
    let bgSlicedProps = this.bgSlicer.sliceProps(
      bgLaneProps,
      dateProfile,
      tDateProfile.isTimeScale ? null : props.nextDayThreshold,
      context,
      // wish we didn't need to pass in the rest of these args...
      dateProfile,
      context.dateProfileGenerator,
      tDateProfile,
      context.dateEnv
    );
    let slatCoords = state.slatCoords && state.slatCoords.dateProfile === props.dateProfile ? state.slatCoords : null;
    return y(
      "div",
      { ref: this.handleEl, className: [
        "fc-timeline-body",
        props.expandRows ? "fc-timeline-body-expandrows" : ""
      ].join(" "), style: { minWidth: props.tableMinWidth } },
      y(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => y(
        _,
        null,
        y(TimelineSlats, { ref: this.slatsRef, dateProfile, tDateProfile, nowDate, todayRange, clientWidth: props.clientWidth, tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, onCoords: this.handleSlatCoords, onScrollLeftRequest: props.onScrollLeftRequest }),
        y(TimelineLaneBg, {
          businessHourSegs: hasResourceBusinessHours ? null : bgSlicedProps.businessHourSegs,
          bgEventSegs: bgSlicedProps.bgEventSegs,
          timelineCoords: slatCoords,
          // empty array will result in unnecessary rerenders?
          eventResizeSegs: bgSlicedProps.eventResize ? bgSlicedProps.eventResize.segs : [],
          dateSelectionSegs: bgSlicedProps.dateSelectionSegs,
          nowDate,
          todayRange
        }),
        y(ResourceTimelineLanes, { rowNodes: props.rowNodes, dateProfile, tDateProfile: props.tDateProfile, nowDate, todayRange, splitProps, fallbackBusinessHours: hasResourceBusinessHours ? props.businessHours : null, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : "", tableMinWidth: props.tableMinWidth, innerHeights: props.rowInnerHeights, slatCoords, onRowCoords: this.handleRowCoords, onRowHeightChange: props.onRowHeightChange }),
        context.options.nowIndicator && slatCoords && slatCoords.isDateInRange(nowDate) && y(
          "div",
          { className: "fc-timeline-now-indicator-container" },
          y(NowIndicatorContainer, { elClasses: ["fc-timeline-now-indicator-line"], elStyle: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl), isAxis: false, date: nowDate })
        )
      ))
    );
  }
  // Hit System
  // ------------------------------------------------------------------------------------------
  queryHit(positionLeft, positionTop) {
    let rowCoords = this.rowCoords;
    let rowIndex = rowCoords.topToIndex(positionTop);
    if (rowIndex != null) {
      let resource = this.props.rowNodes[rowIndex].resource;
      if (resource) {
        let slatHit = this.slatsRef.current.positionToHit(positionLeft);
        if (slatHit) {
          return {
            dateProfile: this.props.dateProfile,
            dateSpan: {
              range: slatHit.dateSpan.range,
              allDay: slatHit.dateSpan.allDay,
              resourceId: resource.id
            },
            rect: {
              left: slatHit.left,
              right: slatHit.right,
              top: rowCoords.tops[rowIndex],
              bottom: rowCoords.bottoms[rowIndex]
            },
            dayEl: slatHit.dayEl,
            layer: 0
          };
        }
      }
    }
    return null;
  }
};
function computeHasResourceBusinessHours(rowNodes) {
  for (let node of rowNodes) {
    let resource = node.resource;
    if (resource && resource.businessHours) {
      return true;
    }
  }
  return false;
}
var MIN_RESOURCE_AREA_WIDTH = 30;
var ResourceTimelineViewLayout = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.scrollGridRef = d();
    this.timeBodyScrollerElRef = d();
    this.spreadsheetHeaderChunkElRef = d();
    this.rootElRef = d();
    this.ensureScrollGridResizeId = 0;
    this.state = {
      resourceAreaWidthOverride: null
    };
    this.ensureScrollGridResize = () => {
      if (this.ensureScrollGridResizeId) {
        clearTimeout(this.ensureScrollGridResizeId);
      }
      this.ensureScrollGridResizeId = setTimeout(() => {
        this.scrollGridRef.current.handleSizing(false);
      }, config.SCROLLGRID_RESIZE_INTERVAL + 1);
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);
    let sections = [
      {
        type: "header",
        key: "header",
        syncRowHeights: true,
        isSticky: stickyHeaderDates,
        chunks: [
          {
            key: "datagrid",
            elRef: this.spreadsheetHeaderChunkElRef,
            // TODO: allow the content to specify this. have general-purpose 'content' with obj with keys
            tableClassName: "fc-datagrid-header",
            rowContent: props.spreadsheetHeaderRows
          },
          {
            key: "divider",
            outerContent: y("td", { role: "presentation", className: "fc-resource-timeline-divider " + context.theme.getClass("tableCellShaded") })
          },
          {
            key: "timeline",
            content: props.timeHeaderContent
          }
        ]
      },
      {
        type: "body",
        key: "body",
        syncRowHeights: true,
        liquid: true,
        expandRows: Boolean(options.expandRows),
        chunks: [
          {
            key: "datagrid",
            tableClassName: "fc-datagrid-body",
            rowContent: props.spreadsheetBodyRows
          },
          {
            key: "divider",
            outerContent: y("td", { role: "presentation", className: "fc-resource-timeline-divider " + context.theme.getClass("tableCellShaded") })
          },
          {
            key: "timeline",
            scrollerElRef: this.timeBodyScrollerElRef,
            content: props.timeBodyContent
          }
        ]
      }
    ];
    if (stickyFooterScrollbar) {
      sections.push({
        type: "footer",
        key: "footer",
        isSticky: true,
        chunks: [
          {
            key: "datagrid",
            content: renderScrollShim
          },
          {
            key: "divider",
            outerContent: y("td", { role: "presentation", className: "fc-resource-timeline-divider " + context.theme.getClass("tableCellShaded") })
          },
          {
            key: "timeline",
            content: renderScrollShim
          }
        ]
      });
    }
    let resourceAreaWidth = state.resourceAreaWidthOverride != null ? state.resourceAreaWidthOverride : options.resourceAreaWidth;
    return y(ScrollGrid, { ref: this.scrollGridRef, elRef: this.rootElRef, liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [
      { cols: props.spreadsheetCols, width: resourceAreaWidth },
      { cols: [] },
      { cols: props.timeCols }
    ], sections });
  }
  forceTimeScroll(left) {
    let scrollGrid = this.scrollGridRef.current;
    scrollGrid.forceScrollLeft(2, left);
  }
  forceResourceScroll(top) {
    let scrollGrid = this.scrollGridRef.current;
    scrollGrid.forceScrollTop(1, top);
  }
  getResourceScroll() {
    let timeBodyScrollerEl = this.timeBodyScrollerElRef.current;
    return timeBodyScrollerEl.scrollTop;
  }
  // Resource Area Resizing
  // ------------------------------------------------------------------------------------------
  // NOTE: a callback Ref for the resizer was firing multiple times with same elements (Preact)
  // that's why we use spreadsheetResizerElRef instead
  componentDidMount() {
    this.initSpreadsheetResizing();
  }
  componentWillUnmount() {
    this.destroySpreadsheetResizing();
  }
  initSpreadsheetResizing() {
    let { isRtl, pluginHooks } = this.context;
    let ElementDraggingImpl = pluginHooks.elementDraggingImpl;
    let spreadsheetHeadEl = this.spreadsheetHeaderChunkElRef.current;
    if (ElementDraggingImpl) {
      let rootEl = this.rootElRef.current;
      let dragging = this.spreadsheetResizerDragging = new ElementDraggingImpl(rootEl, ".fc-resource-timeline-divider");
      let dragStartWidth;
      let viewWidth;
      dragging.emitter.on("dragstart", () => {
        dragStartWidth = spreadsheetHeadEl.getBoundingClientRect().width;
        viewWidth = rootEl.getBoundingClientRect().width;
      });
      dragging.emitter.on("dragmove", (pev) => {
        let newWidth = dragStartWidth + pev.deltaX * (isRtl ? -1 : 1);
        newWidth = Math.max(newWidth, MIN_RESOURCE_AREA_WIDTH);
        newWidth = Math.min(newWidth, viewWidth - MIN_RESOURCE_AREA_WIDTH);
        this.setState({
          resourceAreaWidthOverride: newWidth
        }, this.ensureScrollGridResize);
      });
      dragging.setAutoScrollEnabled(false);
    }
  }
  destroySpreadsheetResizing() {
    if (this.spreadsheetResizerDragging) {
      this.spreadsheetResizerDragging.destroy();
    }
  }
};
var ResourceTimelineView = class extends BaseComponent {
  constructor(props, context) {
    super(props, context);
    this.processColOptions = memoize(processColOptions);
    this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);
    this.hasNesting = memoize(hasNesting);
    this.buildRowNodes = memoize(buildRowNodes);
    this.layoutRef = d();
    this.rowNodes = [];
    this.renderedRowNodes = [];
    this.buildRowIndex = memoize(buildRowIndex);
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
    };
    this.handleRowCoords = (rowCoords) => {
      this.rowCoords = rowCoords;
      this.scrollResponder.update(false);
    };
    this.handleMaxCushionWidth = (slotCushionMaxWidth) => {
      this.setState({
        slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth)
        // for less rerendering TODO: DRY
      });
    };
    this.handleScrollLeftRequest = (scrollLeft) => {
      let layout = this.layoutRef.current;
      layout.forceTimeScroll(scrollLeft);
    };
    this.handleScrollRequest = (request) => {
      let { rowCoords } = this;
      let layout = this.layoutRef.current;
      let rowId = request.rowId || request.resourceId;
      if (rowCoords) {
        if (rowId) {
          let rowIdToIndex = this.buildRowIndex(this.renderedRowNodes);
          let index5 = rowIdToIndex[rowId];
          if (index5 != null) {
            let scrollTop = request.fromBottom != null ? rowCoords.bottoms[index5] - request.fromBottom : (
              // pixels from bottom edge
              rowCoords.tops[index5]
            );
            layout.forceResourceScroll(scrollTop);
          }
        }
        return true;
      }
      return null;
    };
    this.handleColWidthChange = (colWidths) => {
      this.setState({
        spreadsheetColWidths: colWidths
      });
    };
    this.state = {
      resourceAreaWidth: context.options.resourceAreaWidth,
      spreadsheetColWidths: []
    };
  }
  render() {
    let { props, state, context } = this;
    let { options, viewSpec } = context;
    let { superHeaderRendering, groupSpecs, orderSpecs, isVGrouping, colSpecs } = this.processColOptions(context.options);
    let tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);
    let rowNodes = this.rowNodes = this.buildRowNodes(props.resourceStore, groupSpecs, orderSpecs, isVGrouping, props.resourceEntityExpansions, options.resourcesInitiallyExpanded);
    let { slotMinWidth } = options;
    let slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));
    return y(
      ViewContainer,
      { elClasses: [
        "fc-resource-timeline",
        !this.hasNesting(rowNodes) && "fc-resource-timeline-flat",
        "fc-timeline",
        options.eventOverlap === false ? "fc-timeline-overlap-disabled" : "fc-timeline-overlap-enabled"
      ], viewSpec },
      y(ResourceTimelineViewLayout, { ref: this.layoutRef, forPrint: props.forPrint, isHeightAuto: props.isHeightAuto, spreadsheetCols: buildSpreadsheetCols(colSpecs, state.spreadsheetColWidths, ""), spreadsheetHeaderRows: (contentArg) => y(
        SpreadsheetHeader,
        { superHeaderRendering, colSpecs, onColWidthChange: this.handleColWidthChange, rowInnerHeights: contentArg.rowSyncHeights }
      ), spreadsheetBodyRows: (contentArg) => y(_, null, this.renderSpreadsheetRows(rowNodes, colSpecs, contentArg.rowSyncHeights)), timeCols: slatCols, timeHeaderContent: (contentArg) => y(TimelineHeader, { clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, dateProfile: props.dateProfile, tDateProfile, slatCoords: state.slatCoords, rowInnerHeights: contentArg.rowSyncHeights, onMaxCushionWidth: slotMinWidth ? null : this.handleMaxCushionWidth }), timeBodyContent: (contentArg) => y(ResourceTimelineGrid, { dateProfile: props.dateProfile, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, expandRows: contentArg.expandRows, tDateProfile, rowNodes, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, resourceStore: props.resourceStore, nextDayThreshold: context.options.nextDayThreshold, rowInnerHeights: contentArg.rowSyncHeights, onSlatCoords: this.handleSlatCoords, onRowCoords: this.handleRowCoords, onScrollLeftRequest: this.handleScrollLeftRequest, onRowHeightChange: contentArg.reportRowHeightChange }) })
    );
  }
  renderSpreadsheetRows(nodes, colSpecs, rowSyncHeights) {
    return nodes.map((node, index5) => {
      if (node.group) {
        return y(SpreadsheetGroupRow, { key: node.id, id: node.id, spreadsheetColCnt: colSpecs.length, isExpanded: node.isExpanded, group: node.group, innerHeight: rowSyncHeights[index5] || "" });
      }
      if (node.resource) {
        return y(SpreadsheetRow, { key: node.id, colSpecs, rowSpans: node.rowSpans, depth: node.depth, isExpanded: node.isExpanded, hasChildren: node.hasChildren, resource: node.resource, innerHeight: rowSyncHeights[index5] || "" });
      }
      return null;
    });
  }
  componentDidMount() {
    this.renderedRowNodes = this.rowNodes;
    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
  }
  getSnapshotBeforeUpdate() {
    if (!this.props.forPrint) {
      return { resourceScroll: this.queryResourceScroll() };
    }
    return {};
  }
  componentDidUpdate(prevProps, prevState, snapshot) {
    this.renderedRowNodes = this.rowNodes;
    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
    if (snapshot.resourceScroll) {
      this.handleScrollRequest(snapshot.resourceScroll);
    }
  }
  componentWillUnmount() {
    this.scrollResponder.detach();
  }
  computeFallbackSlotMinWidth(tDateProfile) {
    return Math.max(30, (this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel);
  }
  queryResourceScroll() {
    let { rowCoords, renderedRowNodes } = this;
    if (rowCoords) {
      let layout = this.layoutRef.current;
      let trBottoms = rowCoords.bottoms;
      let scrollTop = layout.getResourceScroll();
      let scroll = {};
      for (let i = 0; i < trBottoms.length; i += 1) {
        let rowNode = renderedRowNodes[i];
        let elBottom = trBottoms[i] - scrollTop;
        if (elBottom > 0) {
          scroll.rowId = rowNode.id;
          scroll.fromBottom = elBottom;
          break;
        }
      }
      return scroll;
    }
    return null;
  }
};
ResourceTimelineView.addStateEquality({
  spreadsheetColWidths: isArraysEqual
});
function buildRowIndex(rowNodes) {
  let rowIdToIndex = {};
  for (let i = 0; i < rowNodes.length; i += 1) {
    rowIdToIndex[rowNodes[i].id] = i;
  }
  return rowIdToIndex;
}
function buildSpreadsheetCols(colSpecs, forcedWidths, fallbackWidth = "") {
  return colSpecs.map((colSpec, i) => ({
    className: colSpec.isMain ? "fc-main-col" : "",
    width: forcedWidths[i] || colSpec.width || fallbackWidth
  }));
}
function hasNesting(nodes) {
  for (let node of nodes) {
    if (node.group) {
      return true;
    }
    if (node.resource) {
      if (node.hasChildren) {
        return true;
      }
    }
  }
  return false;
}
function processColOptions(options) {
  let allColSpecs = options.resourceAreaColumns || [];
  let superHeaderRendering = null;
  if (!allColSpecs.length) {
    allColSpecs.push({
      headerClassNames: options.resourceAreaHeaderClassNames,
      headerContent: options.resourceAreaHeaderContent,
      headerDefault: () => "Resources",
      headerDidMount: options.resourceAreaHeaderDidMount,
      headerWillUnmount: options.resourceAreaHeaderWillUnmount
    });
  } else if (options.resourceAreaHeaderContent) {
    superHeaderRendering = {
      headerClassNames: options.resourceAreaHeaderClassNames,
      headerContent: options.resourceAreaHeaderContent,
      headerDidMount: options.resourceAreaHeaderDidMount,
      headerWillUnmount: options.resourceAreaHeaderWillUnmount
    };
  }
  let plainColSpecs = [];
  let groupColSpecs = [];
  let groupSpecs = [];
  let isVGrouping = false;
  for (let colSpec of allColSpecs) {
    if (colSpec.group) {
      groupColSpecs.push(Object.assign(Object.assign({}, colSpec), { cellClassNames: colSpec.cellClassNames || options.resourceGroupLabelClassNames, cellContent: colSpec.cellContent || options.resourceGroupLabelContent, cellDidMount: colSpec.cellDidMount || options.resourceGroupLabelDidMount, cellWillUnmount: colSpec.cellWillUnmount || options.resourceGroupLaneWillUnmount }));
    } else {
      plainColSpecs.push(colSpec);
    }
  }
  let mainColSpec = plainColSpecs[0];
  mainColSpec.isMain = true;
  mainColSpec.cellClassNames = mainColSpec.cellClassNames || options.resourceLabelClassNames;
  mainColSpec.cellContent = mainColSpec.cellContent || options.resourceLabelContent;
  mainColSpec.cellDidMount = mainColSpec.cellDidMount || options.resourceLabelDidMount;
  mainColSpec.cellWillUnmount = mainColSpec.cellWillUnmount || options.resourceLabelWillUnmount;
  if (groupColSpecs.length) {
    groupSpecs = groupColSpecs;
    isVGrouping = true;
  } else {
    let hGroupField = options.resourceGroupField;
    if (hGroupField) {
      groupSpecs.push({
        field: hGroupField,
        labelClassNames: options.resourceGroupLabelClassNames,
        labelContent: options.resourceGroupLabelContent,
        labelDidMount: options.resourceGroupLabelDidMount,
        labelWillUnmount: options.resourceGroupLabelWillUnmount,
        laneClassNames: options.resourceGroupLaneClassNames,
        laneContent: options.resourceGroupLaneContent,
        laneDidMount: options.resourceGroupLaneDidMount,
        laneWillUnmount: options.resourceGroupLaneWillUnmount
      });
    }
  }
  let allOrderSpecs = options.resourceOrder || DEFAULT_RESOURCE_ORDER;
  let plainOrderSpecs = [];
  for (let orderSpec of allOrderSpecs) {
    let isGroup = false;
    for (let groupSpec of groupSpecs) {
      if (groupSpec.field === orderSpec.field) {
        groupSpec.order = orderSpec.order;
        isGroup = true;
        break;
      }
    }
    if (!isGroup) {
      plainOrderSpecs.push(orderSpec);
    }
  }
  return {
    superHeaderRendering,
    isVGrouping,
    groupSpecs,
    colSpecs: groupColSpecs.concat(plainColSpecs),
    orderSpecs: plainOrderSpecs
  };
}

// node_modules/@fullcalendar/resource-timeline/index.js
var index4 = createPlugin({
  name: "@fullcalendar/resource-timeline",
  premiumReleaseDate: "2023-05-25",
  deps: [
    index,
    index3,
    index2
  ],
  initialView: "resourceTimelineDay",
  views: {
    resourceTimeline: {
      type: "timeline",
      component: ResourceTimelineView,
      needsResourceData: true,
      resourceAreaWidth: "30%",
      resourcesInitiallyExpanded: true,
      eventResizableFromStart: true
      // TODO: not DRY with this same setting in the main timeline config
    },
    resourceTimelineDay: {
      type: "resourceTimeline",
      duration: { days: 1 }
    },
    resourceTimelineWeek: {
      type: "resourceTimeline",
      duration: { weeks: 1 }
    },
    resourceTimelineMonth: {
      type: "resourceTimeline",
      duration: { months: 1 }
    },
    resourceTimelineYear: {
      type: "resourceTimeline",
      duration: { years: 1 }
    }
  }
});
export {
  index4 as default
};
//# sourceMappingURL=@fullcalendar_resource-timeline.js.map
