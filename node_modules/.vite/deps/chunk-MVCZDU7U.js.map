{
  "version": 3,
  "sources": ["../../@fullcalendar/premium-common/index.js", "../../@fullcalendar/scrollgrid/internal.js", "../../@fullcalendar/timeline/internal.js", "../../@fullcalendar/timeline/index.js"],
  "sourcesContent": ["import { createPlugin } from '@fullcalendar/core/index.js';\r\nimport { config, isValidDate, addDays } from '@fullcalendar/core/internal.js';\r\nimport { createElement, Fragment } from '@fullcalendar/core/preact.js';\r\n\r\nconst UPGRADE_WINDOW = 365 + 7; // days. 1 week leeway, for tz shift reasons too\r\nconst INVALID_LICENSE_URL = 'https://fullcalendar.io/docs/schedulerLicenseKey#invalid';\r\nconst OUTDATED_LICENSE_URL = 'https://fullcalendar.io/docs/schedulerLicenseKey#outdated';\r\nconst PRESET_LICENSE_KEYS = [\r\n    'GPL-My-Project-Is-Open-Source',\r\n    'CC-Attribution-NonCommercial-NoDerivatives',\r\n];\r\nconst CSS = {\r\n    position: 'absolute',\r\n    zIndex: 99999,\r\n    bottom: '1px',\r\n    left: '1px',\r\n    background: '#eee',\r\n    borderColor: '#ddd',\r\n    borderStyle: 'solid',\r\n    borderWidth: '1px 1px 0 0',\r\n    padding: '2px 4px',\r\n    fontSize: '12px',\r\n    borderTopRightRadius: '3px',\r\n};\r\nfunction buildLicenseWarning(context) {\r\n    let key = context.options.schedulerLicenseKey;\r\n    let currentUrl = typeof window !== 'undefined' ? window.location.href : '';\r\n    if (!isImmuneUrl(currentUrl)) {\r\n        let status = processLicenseKey(key, context.pluginHooks.premiumReleaseDate);\r\n        if (status !== 'valid') {\r\n            return (createElement(\"div\", { className: \"fc-license-message\", style: CSS }, (status === 'outdated') ? (createElement(Fragment, null,\r\n                'Your license key is too old to work with this version. ',\r\n                createElement(\"a\", { href: OUTDATED_LICENSE_URL }, \"More Info\"))) : (createElement(Fragment, null,\r\n                'Your license key is invalid. ',\r\n                createElement(\"a\", { href: INVALID_LICENSE_URL }, \"More Info\")))));\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/*\r\nThis decryption is not meant to be bulletproof. Just a way to remind about an upgrade.\r\n*/\r\nfunction processLicenseKey(key, premiumReleaseDate) {\r\n    if (PRESET_LICENSE_KEYS.indexOf(key) !== -1) {\r\n        return 'valid';\r\n    }\r\n    const parts = (key || '').match(/^(\\d+)-fcs-(\\d+)$/);\r\n    if (parts && (parts[1].length === 10)) {\r\n        const purchaseDate = new Date(parseInt(parts[2], 10) * 1000);\r\n        const releaseDate = config.mockSchedulerReleaseDate || premiumReleaseDate;\r\n        if (isValidDate(releaseDate)) { // token won't be replaced in dev mode\r\n            const minPurchaseDate = addDays(releaseDate, -UPGRADE_WINDOW);\r\n            if (minPurchaseDate < purchaseDate) {\r\n                return 'valid';\r\n            }\r\n            return 'outdated';\r\n        }\r\n    }\r\n    return 'invalid';\r\n}\r\nfunction isImmuneUrl(url) {\r\n    return /\\w+:\\/\\/fullcalendar\\.io\\/|\\/examples\\/[\\w-]+\\.html$/.test(url);\r\n}\r\n\r\nconst OPTION_REFINERS = {\r\n    schedulerLicenseKey: String,\r\n};\r\n\r\nvar index = createPlugin({\r\n    name: '@fullcalendar/premium-common',\r\n    premiumReleaseDate: '2023-05-25',\r\n    optionRefiners: OPTION_REFINERS,\r\n    viewContainerAppends: [buildLicenseWarning],\r\n});\r\n\r\nexport { index as default };\r\n", "import { computeEdges, removeElement, findElements, translateRect, computeInnerRect, applyStyle, BaseComponent, setRef, getIsRtlScrollbarOnLeft, Scroller, isPropsEqual, Emitter, DelayedRunner, config, memoizeArraylike, renderMicroColGroup, RefMap, getScrollGridClassNames, getCanVGrowWithinCell, getSectionClassNames, getAllowYScrolling, getSectionHasLiquidHeight, renderChunkContent, memoizeHashlike, computeShrinkWidth, getScrollbarWidths, collectFromHash, mapHash, isArraysEqual, sanitizeShrinkWidth, hasShrinkWidth, compareObjs, isColPropsEqual } from '@fullcalendar/core/internal.js';\r\nimport { createRef, createElement, Fragment } from '@fullcalendar/core/preact.js';\r\n\r\n// TODO: assume the el has no borders?\r\nfunction getScrollCanvasOrigin(scrollEl) {\r\n    let rect = scrollEl.getBoundingClientRect();\r\n    let edges = computeEdges(scrollEl); // TODO: pass in isRtl?\r\n    return {\r\n        left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\r\n        top: rect.top + edges.borderTop - scrollEl.scrollTop,\r\n    };\r\n}\r\nfunction getScrollFromLeftEdge(el) {\r\n    let scrollLeft = el.scrollLeft;\r\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\r\n    if (computedStyles.direction === 'rtl') {\r\n        switch (getRtlScrollSystem()) {\r\n            case 'negative':\r\n                scrollLeft *= -1; // convert to 'reverse'. fall through...\r\n            case 'reverse': // scrollLeft is distance between scrollframe's right edge scrollcanvas's right edge\r\n                scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth;\r\n        }\r\n    }\r\n    return scrollLeft;\r\n}\r\nfunction setScrollFromLeftEdge(el, scrollLeft) {\r\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\r\n    if (computedStyles.direction === 'rtl') {\r\n        switch (getRtlScrollSystem()) {\r\n            case 'reverse':\r\n                scrollLeft = el.scrollWidth - scrollLeft;\r\n                break;\r\n            case 'negative':\r\n                scrollLeft = -(el.scrollWidth - scrollLeft);\r\n                break;\r\n        }\r\n    }\r\n    el.scrollLeft = scrollLeft;\r\n}\r\n// Horizontal Scroll System Detection\r\n// ----------------------------------------------------------------------------------------------\r\nlet _rtlScrollSystem;\r\nfunction getRtlScrollSystem() {\r\n    return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());\r\n}\r\nfunction detectRtlScrollSystem() {\r\n    let el = document.createElement('div');\r\n    el.style.position = 'absolute';\r\n    el.style.top = '-1000px';\r\n    el.style.width = '1px';\r\n    el.style.height = '1px';\r\n    el.style.overflow = 'scroll';\r\n    el.style.direction = 'rtl';\r\n    el.style.fontSize = '100px';\r\n    el.innerHTML = 'A';\r\n    document.body.appendChild(el);\r\n    let system;\r\n    if (el.scrollLeft > 0) {\r\n        system = 'positive'; // scroll is a positive number from the left edge\r\n    }\r\n    else {\r\n        el.scrollLeft = 1;\r\n        if (el.scrollLeft > 0) {\r\n            system = 'reverse'; // scroll is a positive number from the right edge\r\n        }\r\n        else {\r\n            system = 'negative'; // scroll is a negative number from the right edge\r\n        }\r\n    }\r\n    removeElement(el);\r\n    return system;\r\n}\r\n\r\nconst STICKY_SELECTOR = '.fc-sticky';\r\n/*\r\nGoes beyond mere position:sticky, allows horizontal centering\r\n\r\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\r\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\r\n\r\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\r\n*/\r\nclass StickyScrolling {\r\n    constructor(scrollEl, isRtl) {\r\n        this.scrollEl = scrollEl;\r\n        this.isRtl = isRtl;\r\n        this.updateSize = () => {\r\n            let { scrollEl } = this;\r\n            let els = findElements(scrollEl, STICKY_SELECTOR);\r\n            let elGeoms = this.queryElGeoms(els);\r\n            let viewportWidth = scrollEl.clientWidth;\r\n            assignStickyPositions(els, elGeoms, viewportWidth);\r\n        };\r\n    }\r\n    queryElGeoms(els) {\r\n        let { scrollEl, isRtl } = this;\r\n        let canvasOrigin = getScrollCanvasOrigin(scrollEl);\r\n        let elGeoms = [];\r\n        for (let el of els) {\r\n            let parentBound = translateRect(computeInnerRect(el.parentNode, true, true), // weird way to call this!!!\r\n            -canvasOrigin.left, -canvasOrigin.top);\r\n            let elRect = el.getBoundingClientRect();\r\n            let computedStyles = window.getComputedStyle(el);\r\n            let textAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent\r\n            let naturalBound = null;\r\n            if (textAlign === 'start') {\r\n                textAlign = isRtl ? 'right' : 'left';\r\n            }\r\n            else if (textAlign === 'end') {\r\n                textAlign = isRtl ? 'left' : 'right';\r\n            }\r\n            if (computedStyles.position !== 'sticky') {\r\n                naturalBound = translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'\r\n                -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));\r\n            }\r\n            elGeoms.push({\r\n                parentBound,\r\n                naturalBound,\r\n                elWidth: elRect.width,\r\n                elHeight: elRect.height,\r\n                textAlign,\r\n            });\r\n        }\r\n        return elGeoms;\r\n    }\r\n}\r\nfunction assignStickyPositions(els, elGeoms, viewportWidth) {\r\n    els.forEach((el, i) => {\r\n        let { textAlign, elWidth, parentBound } = elGeoms[i];\r\n        let parentWidth = parentBound.right - parentBound.left;\r\n        let left;\r\n        if (textAlign === 'center' &&\r\n            parentWidth > viewportWidth) {\r\n            left = (viewportWidth - elWidth) / 2;\r\n        }\r\n        else { // if parent container can be completely in view, we don't need stickiness\r\n            left = '';\r\n        }\r\n        applyStyle(el, {\r\n            left,\r\n            right: left,\r\n            top: 0,\r\n        });\r\n    });\r\n}\r\n\r\nclass ClippedScroller extends BaseComponent {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.elRef = createRef();\r\n        this.state = {\r\n            xScrollbarWidth: 0,\r\n            yScrollbarWidth: 0,\r\n        };\r\n        this.handleScroller = (scroller) => {\r\n            this.scroller = scroller;\r\n            setRef(this.props.scrollerRef, scroller);\r\n        };\r\n        this.handleSizing = () => {\r\n            let { props } = this;\r\n            if (props.overflowY === 'scroll-hidden') {\r\n                this.setState({ yScrollbarWidth: this.scroller.getYScrollbarWidth() });\r\n            }\r\n            if (props.overflowX === 'scroll-hidden') {\r\n                this.setState({ xScrollbarWidth: this.scroller.getXScrollbarWidth() });\r\n            }\r\n        };\r\n    }\r\n    render() {\r\n        let { props, state, context } = this;\r\n        let isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();\r\n        let overcomeLeft = 0;\r\n        let overcomeRight = 0;\r\n        let overcomeBottom = 0;\r\n        let { overflowX, overflowY } = props;\r\n        if (props.forPrint) {\r\n            overflowX = 'visible';\r\n            overflowY = 'visible';\r\n        }\r\n        if (overflowX === 'scroll-hidden') {\r\n            overcomeBottom = state.xScrollbarWidth;\r\n        }\r\n        if (overflowY === 'scroll-hidden') {\r\n            if (state.yScrollbarWidth != null) {\r\n                if (isScrollbarOnLeft) {\r\n                    overcomeLeft = state.yScrollbarWidth;\r\n                }\r\n                else {\r\n                    overcomeRight = state.yScrollbarWidth;\r\n                }\r\n            }\r\n        }\r\n        return (createElement(\"div\", { ref: this.elRef, className: 'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '') },\r\n            createElement(Scroller, { ref: this.handleScroller, elRef: this.props.scrollerElRef, overflowX: overflowX === 'scroll-hidden' ? 'scroll' : overflowX, overflowY: overflowY === 'scroll-hidden' ? 'scroll' : overflowY, overcomeLeft: overcomeLeft, overcomeRight: overcomeRight, overcomeBottom: overcomeBottom, maxHeight: typeof props.maxHeight === 'number'\r\n                    ? (props.maxHeight + (overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0))\r\n                    : '', liquid: props.liquid, liquidIsAbsolute: true }, props.children)));\r\n    }\r\n    componentDidMount() {\r\n        this.handleSizing();\r\n        this.context.addResizeHandler(this.handleSizing);\r\n    }\r\n    getSnapshotBeforeUpdate(prevProps) {\r\n        if (this.props.forPrint && !prevProps.forPrint) {\r\n            return { simulateScrollLeft: this.scroller.el.scrollLeft };\r\n        }\r\n        return {};\r\n    }\r\n    componentDidUpdate(prevProps, prevState, snapshot) {\r\n        const { props, scroller: { el: scrollerEl } } = this;\r\n        if (!isPropsEqual(prevProps, props)) { // an external change?\r\n            this.handleSizing();\r\n        }\r\n        if (snapshot.simulateScrollLeft !== undefined) {\r\n            scrollerEl.style.left = -snapshot.simulateScrollLeft + 'px';\r\n        }\r\n        else if (!props.forPrint && prevProps.forPrint) {\r\n            const restoredScrollLeft = -parseInt(scrollerEl.style.left);\r\n            scrollerEl.style.left = '';\r\n            scrollerEl.scrollLeft = restoredScrollLeft;\r\n        }\r\n    }\r\n    componentWillUnmount() {\r\n        this.context.removeResizeHandler(this.handleSizing);\r\n    }\r\n    needsXScrolling() {\r\n        return this.scroller.needsXScrolling();\r\n    }\r\n    needsYScrolling() {\r\n        return this.scroller.needsYScrolling();\r\n    }\r\n}\r\n\r\nconst WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ');\r\n/*\r\nALSO, with the ability to disable touch\r\n*/\r\nclass ScrollListener {\r\n    constructor(el) {\r\n        this.el = el;\r\n        this.emitter = new Emitter();\r\n        this.isScrolling = false;\r\n        this.isTouching = false; // user currently has finger down?\r\n        this.isRecentlyWheeled = false;\r\n        this.isRecentlyScrolled = false;\r\n        this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));\r\n        this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this));\r\n        // Handlers\r\n        // ----------------------------------------------------------------------------------------------\r\n        this.handleScroll = () => {\r\n            this.startScroll();\r\n            this.emitter.trigger('scroll', this.isRecentlyWheeled, this.isTouching);\r\n            this.isRecentlyScrolled = true;\r\n            this.scrollWaiter.request(500);\r\n        };\r\n        // will fire *before* the scroll event is fired (might not cause a scroll)\r\n        this.handleWheel = () => {\r\n            this.isRecentlyWheeled = true;\r\n            this.wheelWaiter.request(500);\r\n        };\r\n        // will fire *before* the scroll event is fired (might not cause a scroll)\r\n        this.handleTouchStart = () => {\r\n            this.isTouching = true;\r\n        };\r\n        this.handleTouchEnd = () => {\r\n            this.isTouching = false;\r\n            // if the user ended their touch, and the scroll area wasn't moving,\r\n            // we consider this to be the end of the scroll.\r\n            if (!this.isRecentlyScrolled) {\r\n                this.endScroll(); // won't fire if already ended\r\n            }\r\n        };\r\n        el.addEventListener('scroll', this.handleScroll);\r\n        el.addEventListener('touchstart', this.handleTouchStart, { passive: true });\r\n        el.addEventListener('touchend', this.handleTouchEnd);\r\n        for (let eventName of WHEEL_EVENT_NAMES) {\r\n            el.addEventListener(eventName, this.handleWheel);\r\n        }\r\n    }\r\n    destroy() {\r\n        let { el } = this;\r\n        el.removeEventListener('scroll', this.handleScroll);\r\n        el.removeEventListener('touchstart', this.handleTouchStart, { passive: true });\r\n        el.removeEventListener('touchend', this.handleTouchEnd);\r\n        for (let eventName of WHEEL_EVENT_NAMES) {\r\n            el.removeEventListener(eventName, this.handleWheel);\r\n        }\r\n    }\r\n    // Start / Stop\r\n    // ----------------------------------------------------------------------------------------------\r\n    startScroll() {\r\n        if (!this.isScrolling) {\r\n            this.isScrolling = true;\r\n            this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching);\r\n        }\r\n    }\r\n    endScroll() {\r\n        if (this.isScrolling) {\r\n            this.emitter.trigger('scrollEnd');\r\n            this.isScrolling = false;\r\n            this.isRecentlyScrolled = true;\r\n            this.isRecentlyWheeled = false;\r\n            this.scrollWaiter.clear();\r\n            this.wheelWaiter.clear();\r\n        }\r\n    }\r\n    _handleScrollWaited() {\r\n        this.isRecentlyScrolled = false;\r\n        // only end the scroll if not currently touching.\r\n        // if touching, the scrolling will end later, on touchend.\r\n        if (!this.isTouching) {\r\n            this.endScroll(); // won't fire if already ended\r\n        }\r\n    }\r\n    _handleWheelWaited() {\r\n        this.isRecentlyWheeled = false;\r\n    }\r\n}\r\n\r\nclass ScrollSyncer {\r\n    constructor(isVertical, scrollEls) {\r\n        this.isVertical = isVertical;\r\n        this.scrollEls = scrollEls;\r\n        this.isPaused = false;\r\n        this.scrollListeners = scrollEls.map((el) => this.bindScroller(el));\r\n    }\r\n    destroy() {\r\n        for (let scrollListener of this.scrollListeners) {\r\n            scrollListener.destroy();\r\n        }\r\n    }\r\n    bindScroller(el) {\r\n        let { scrollEls, isVertical } = this;\r\n        let scrollListener = new ScrollListener(el);\r\n        const onScroll = (isWheel, isTouch) => {\r\n            if (!this.isPaused) {\r\n                if (!this.masterEl || (this.masterEl !== el && (isWheel || isTouch))) {\r\n                    this.assignMaster(el);\r\n                }\r\n                if (this.masterEl === el) { // dealing with current\r\n                    for (let otherEl of scrollEls) {\r\n                        if (otherEl !== el) {\r\n                            if (isVertical) {\r\n                                otherEl.scrollTop = el.scrollTop;\r\n                            }\r\n                            else {\r\n                                otherEl.scrollLeft = el.scrollLeft;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        const onScrollEnd = () => {\r\n            if (this.masterEl === el) {\r\n                this.masterEl = null;\r\n            }\r\n        };\r\n        scrollListener.emitter.on('scroll', onScroll);\r\n        scrollListener.emitter.on('scrollEnd', onScrollEnd);\r\n        return scrollListener;\r\n    }\r\n    assignMaster(el) {\r\n        this.masterEl = el;\r\n        for (let scrollListener of this.scrollListeners) {\r\n            if (scrollListener.el !== el) {\r\n                scrollListener.endScroll(); // to prevent residual scrolls from reclaiming master\r\n            }\r\n        }\r\n    }\r\n    /*\r\n    will normalize the scrollLeft value\r\n    */\r\n    forceScrollLeft(scrollLeft) {\r\n        this.isPaused = true;\r\n        for (let listener of this.scrollListeners) {\r\n            setScrollFromLeftEdge(listener.el, scrollLeft);\r\n        }\r\n        this.isPaused = false;\r\n    }\r\n    forceScrollTop(top) {\r\n        this.isPaused = true;\r\n        for (let listener of this.scrollListeners) {\r\n            listener.el.scrollTop = top;\r\n        }\r\n        this.isPaused = false;\r\n    }\r\n}\r\n\r\nconfig.SCROLLGRID_RESIZE_INTERVAL = 500;\r\n/*\r\nTODO: make <ScrollGridSection> subcomponent\r\nNOTE: doesn't support collapsibleWidth (which is sortof a hack anyway)\r\n*/\r\nclass ScrollGrid extends BaseComponent {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);\r\n        this.renderMicroColGroups = memoizeArraylike(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers\r\n        this.clippedScrollerRefs = new RefMap();\r\n        // doesn't hold non-scrolling els used just for padding\r\n        this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\r\n        this.chunkElRefs = new RefMap(this._handleChunkEl.bind(this));\r\n        this.scrollSyncersBySection = {};\r\n        this.scrollSyncersByColumn = {};\r\n        // for row-height-syncing\r\n        this.rowUnstableMap = new Map(); // no need to groom. always self-cancels\r\n        this.rowInnerMaxHeightMap = new Map();\r\n        this.anyRowHeightsChanged = false;\r\n        this.recentSizingCnt = 0;\r\n        this.state = {\r\n            shrinkWidths: [],\r\n            forceYScrollbars: false,\r\n            forceXScrollbars: false,\r\n            scrollerClientWidths: {},\r\n            scrollerClientHeights: {},\r\n            sectionRowMaxHeights: [],\r\n        };\r\n        this.handleSizing = (isForcedResize, sectionRowMaxHeightsChanged) => {\r\n            if (!this.allowSizing()) {\r\n                return;\r\n            }\r\n            if (!sectionRowMaxHeightsChanged) { // something else changed, probably external\r\n                this.anyRowHeightsChanged = true;\r\n            }\r\n            let otherState = {};\r\n            // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\r\n            if (isForcedResize || (!sectionRowMaxHeightsChanged && !this.rowUnstableMap.size)) {\r\n                otherState.sectionRowMaxHeights = this.computeSectionRowMaxHeights();\r\n            }\r\n            this.setState(Object.assign(Object.assign({ shrinkWidths: this.computeShrinkWidths() }, this.computeScrollerDims()), otherState), () => {\r\n                if (!this.rowUnstableMap.size) {\r\n                    this.updateStickyScrolling(); // needs to happen AFTER final positioning committed to DOM\r\n                }\r\n            });\r\n        };\r\n        this.handleRowHeightChange = (rowEl, isStable) => {\r\n            let { rowUnstableMap, rowInnerMaxHeightMap } = this;\r\n            if (!isStable) {\r\n                rowUnstableMap.set(rowEl, true);\r\n            }\r\n            else {\r\n                rowUnstableMap.delete(rowEl);\r\n                let innerMaxHeight = getRowInnerMaxHeight(rowEl);\r\n                if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\r\n                    rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);\r\n                    this.anyRowHeightsChanged = true;\r\n                }\r\n                if (!rowUnstableMap.size && this.anyRowHeightsChanged) {\r\n                    this.anyRowHeightsChanged = false;\r\n                    this.setState({\r\n                        sectionRowMaxHeights: this.computeSectionRowMaxHeights(),\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n    render() {\r\n        let { props, state, context } = this;\r\n        let { shrinkWidths } = state;\r\n        let colGroupStats = this.compileColGroupStats(props.colGroups.map((colGroup) => [colGroup]));\r\n        let microColGroupNodes = this.renderMicroColGroups(colGroupStats.map((stat, i) => [stat.cols, shrinkWidths[i]]));\r\n        let classNames = getScrollGridClassNames(props.liquid, context);\r\n        this.getDims();\r\n        // TODO: make DRY\r\n        let sectionConfigs = props.sections;\r\n        let configCnt = sectionConfigs.length;\r\n        let configI = 0;\r\n        let currentConfig;\r\n        let headSectionNodes = [];\r\n        let bodySectionNodes = [];\r\n        let footSectionNodes = [];\r\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\r\n            headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\r\n            configI += 1;\r\n        }\r\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\r\n            bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, false));\r\n            configI += 1;\r\n        }\r\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\r\n            footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\r\n            configI += 1;\r\n        }\r\n        const isBuggy = !getCanVGrowWithinCell(); // see NOTE in SimpleScrollGrid\r\n        const roleAttrs = { role: 'rowgroup' };\r\n        return createElement('table', {\r\n            ref: props.elRef,\r\n            role: 'grid',\r\n            className: classNames.join(' '),\r\n        }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && createElement('thead', roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && createElement('tbody', roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && createElement('tfoot', roleAttrs, ...footSectionNodes), isBuggy && createElement('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\r\n    }\r\n    renderSection(sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights, isHeader) {\r\n        if ('outerContent' in sectionConfig) {\r\n            return (createElement(Fragment, { key: sectionConfig.key }, sectionConfig.outerContent));\r\n        }\r\n        return (createElement(\"tr\", { key: sectionConfig.key, role: \"presentation\", className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ') }, sectionConfig.chunks.map((chunkConfig, i) => this.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || [], isHeader))));\r\n    }\r\n    renderChunk(sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights, isHeader) {\r\n        if ('outerContent' in chunkConfig) {\r\n            return (createElement(Fragment, { key: chunkConfig.key }, chunkConfig.outerContent));\r\n        }\r\n        let { state } = this;\r\n        let { scrollerClientWidths, scrollerClientHeights } = state;\r\n        let [sectionCnt, chunksPerSection] = this.getDims();\r\n        let index = sectionIndex * chunksPerSection + chunkIndex;\r\n        let sideScrollIndex = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\r\n        let isVScrollSide = chunkIndex === sideScrollIndex;\r\n        let isLastSection = sectionIndex === sectionCnt - 1;\r\n        let forceXScrollbars = isLastSection && state.forceXScrollbars; // NOOOO can result in `null`\r\n        let forceYScrollbars = isVScrollSide && state.forceYScrollbars; // NOOOO can result in `null`\r\n        let allowXScrolling = colGroupStat && colGroupStat.allowXScrolling; // rename?\r\n        let allowYScrolling = getAllowYScrolling(this.props, sectionConfig); // rename? do in section func?\r\n        let chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig); // do in section func?\r\n        let expandRows = sectionConfig.expandRows && chunkVGrow;\r\n        let tableMinWidth = (colGroupStat && colGroupStat.totalColMinWidth) || '';\r\n        let content = renderChunkContent(sectionConfig, chunkConfig, {\r\n            tableColGroupNode: microColGroupNode,\r\n            tableMinWidth,\r\n            clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\r\n            clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\r\n            expandRows,\r\n            syncRowHeights: Boolean(sectionConfig.syncRowHeights),\r\n            rowSyncHeights: rowHeights,\r\n            reportRowHeightChange: this.handleRowHeightChange,\r\n        }, isHeader);\r\n        let overflowX = forceXScrollbars ? (isLastSection ? 'scroll' : 'scroll-hidden') :\r\n            !allowXScrolling ? 'hidden' :\r\n                (isLastSection ? 'auto' : 'scroll-hidden');\r\n        let overflowY = forceYScrollbars ? (isVScrollSide ? 'scroll' : 'scroll-hidden') :\r\n            !allowYScrolling ? 'hidden' :\r\n                (isVScrollSide ? 'auto' : 'scroll-hidden');\r\n        // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\r\n        // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\r\n        content = (createElement(ClippedScroller, { ref: this.clippedScrollerRefs.createRef(index), scrollerElRef: this.scrollerElRefs.createRef(index), overflowX: overflowX, overflowY: overflowY, forPrint: this.props.forPrint, liquid: chunkVGrow, maxHeight: sectionConfig.maxHeight }, content));\r\n        return createElement(isHeader ? 'th' : 'td', {\r\n            key: chunkConfig.key,\r\n            ref: this.chunkElRefs.createRef(index),\r\n            role: 'presentation',\r\n        }, content);\r\n    }\r\n    componentDidMount() {\r\n        this.getStickyScrolling = memoizeArraylike(initStickyScrolling);\r\n        this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer);\r\n        this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer);\r\n        this.updateScrollSyncers();\r\n        this.handleSizing(false);\r\n        this.context.addResizeHandler(this.handleSizing);\r\n    }\r\n    componentDidUpdate(prevProps, prevState) {\r\n        this.updateScrollSyncers();\r\n        // TODO: need better solution when state contains non-sizing things\r\n        this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);\r\n    }\r\n    componentWillUnmount() {\r\n        this.context.removeResizeHandler(this.handleSizing);\r\n        this.destroyScrollSyncers();\r\n    }\r\n    allowSizing() {\r\n        let now = new Date();\r\n        if (!this.lastSizingDate ||\r\n            now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL) {\r\n            this.lastSizingDate = now;\r\n            this.recentSizingCnt = 0;\r\n            return true;\r\n        }\r\n        return (this.recentSizingCnt += 1) <= 10;\r\n    }\r\n    computeShrinkWidths() {\r\n        let colGroupStats = this.compileColGroupStats(this.props.colGroups.map((colGroup) => [colGroup]));\r\n        let [sectionCnt, chunksPerSection] = this.getDims();\r\n        let cnt = sectionCnt * chunksPerSection;\r\n        let shrinkWidths = [];\r\n        colGroupStats.forEach((colGroupStat, i) => {\r\n            if (colGroupStat.hasShrinkCol) {\r\n                let chunkEls = this.chunkElRefs.collect(i, cnt, chunksPerSection); // in one col\r\n                shrinkWidths[i] = computeShrinkWidth(chunkEls);\r\n            }\r\n        });\r\n        return shrinkWidths;\r\n    }\r\n    // has the side effect of grooming rowInnerMaxHeightMap\r\n    // TODO: somehow short-circuit if there are no new height changes\r\n    computeSectionRowMaxHeights() {\r\n        let newHeightMap = new Map();\r\n        let [sectionCnt, chunksPerSection] = this.getDims();\r\n        let sectionRowMaxHeights = [];\r\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\r\n            let sectionConfig = this.props.sections[sectionI];\r\n            let assignableHeights = []; // chunk, row\r\n            if (sectionConfig && sectionConfig.syncRowHeights) {\r\n                let rowHeightsByChunk = [];\r\n                for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\r\n                    let index = sectionI * chunksPerSection + chunkI;\r\n                    let rowHeights = [];\r\n                    let chunkEl = this.chunkElRefs.currentMap[index];\r\n                    if (chunkEl) {\r\n                        rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map((rowEl) => {\r\n                            let max = getRowInnerMaxHeight(rowEl);\r\n                            newHeightMap.set(rowEl, max);\r\n                            return max;\r\n                        });\r\n                    }\r\n                    else {\r\n                        rowHeights = [];\r\n                    }\r\n                    rowHeightsByChunk.push(rowHeights);\r\n                }\r\n                let rowCnt = rowHeightsByChunk[0].length;\r\n                let isEqualRowCnt = true;\r\n                for (let chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {\r\n                    let isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined; // can be null\r\n                    if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) { // skip outer content\r\n                        isEqualRowCnt = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!isEqualRowCnt) {\r\n                    let chunkHeightSums = [];\r\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\r\n                        chunkHeightSums.push(sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length);\r\n                    }\r\n                    let maxTotalSum = Math.max(...chunkHeightSums);\r\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\r\n                        let rowInChunkCnt = rowHeightsByChunk[chunkI].length;\r\n                        let rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt; // subtract border\r\n                        // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\r\n                        let rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt);\r\n                        // whatever is leftover goes to the first row\r\n                        let rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);\r\n                        let rowInChunkHeights = [];\r\n                        let row = 0;\r\n                        if (row < rowInChunkCnt) {\r\n                            rowInChunkHeights.push(rowInChunkHeightFirst);\r\n                            row += 1;\r\n                        }\r\n                        while (row < rowInChunkCnt) {\r\n                            rowInChunkHeights.push(rowInChunkHeightOthers);\r\n                            row += 1;\r\n                        }\r\n                        assignableHeights.push(rowInChunkHeights);\r\n                    }\r\n                }\r\n                else {\r\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\r\n                        assignableHeights.push([]);\r\n                    }\r\n                    for (let row = 0; row < rowCnt; row += 1) {\r\n                        let rowHeightsAcrossChunks = [];\r\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\r\n                            let h = rowHeightsByChunk[chunkI][row];\r\n                            if (h != null) { // protect against outerContent\r\n                                rowHeightsAcrossChunks.push(h);\r\n                            }\r\n                        }\r\n                        let maxHeight = Math.max(...rowHeightsAcrossChunks);\r\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\r\n                            assignableHeights[chunkI].push(maxHeight);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            sectionRowMaxHeights.push(assignableHeights);\r\n        }\r\n        this.rowInnerMaxHeightMap = newHeightMap;\r\n        return sectionRowMaxHeights;\r\n    }\r\n    computeScrollerDims() {\r\n        let scrollbarWidth = getScrollbarWidths();\r\n        let [sectionCnt, chunksPerSection] = this.getDims();\r\n        let sideScrollI = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\r\n        let lastSectionI = sectionCnt - 1;\r\n        let currentScrollers = this.clippedScrollerRefs.currentMap;\r\n        let scrollerEls = this.scrollerElRefs.currentMap;\r\n        let forceYScrollbars = false;\r\n        let forceXScrollbars = false;\r\n        let scrollerClientWidths = {};\r\n        let scrollerClientHeights = {};\r\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) { // along edge\r\n            let index = sectionI * chunksPerSection + sideScrollI;\r\n            let scroller = currentScrollers[index];\r\n            if (scroller && scroller.needsYScrolling()) {\r\n                forceYScrollbars = true;\r\n                break;\r\n            }\r\n        }\r\n        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) { // along last row\r\n            let index = lastSectionI * chunksPerSection + chunkI;\r\n            let scroller = currentScrollers[index];\r\n            if (scroller && scroller.needsXScrolling()) {\r\n                forceXScrollbars = true;\r\n                break;\r\n            }\r\n        }\r\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\r\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\r\n                let index = sectionI * chunksPerSection + chunkI;\r\n                let scrollerEl = scrollerEls[index];\r\n                if (scrollerEl) {\r\n                    // TODO: weird way to get this. need harness b/c doesn't include table borders\r\n                    let harnessEl = scrollerEl.parentNode;\r\n                    scrollerClientWidths[index] = Math.floor(harnessEl.getBoundingClientRect().width - ((chunkI === sideScrollI && forceYScrollbars)\r\n                        ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\r\n                        : 0));\r\n                    scrollerClientHeights[index] = Math.floor(harnessEl.getBoundingClientRect().height - ((sectionI === lastSectionI && forceXScrollbars)\r\n                        ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\r\n                        : 0));\r\n                }\r\n            }\r\n        }\r\n        return { forceYScrollbars, forceXScrollbars, scrollerClientWidths, scrollerClientHeights };\r\n    }\r\n    updateStickyScrolling() {\r\n        let { isRtl } = this.context;\r\n        let argsByKey = this.scrollerElRefs.getAll().map((scrollEl) => [scrollEl, isRtl]);\r\n        this.getStickyScrolling(argsByKey)\r\n            .forEach((stickyScrolling) => stickyScrolling.updateSize());\r\n    }\r\n    updateScrollSyncers() {\r\n        let [sectionCnt, chunksPerSection] = this.getDims();\r\n        let cnt = sectionCnt * chunksPerSection;\r\n        let scrollElsBySection = {};\r\n        let scrollElsByColumn = {};\r\n        let scrollElMap = this.scrollerElRefs.currentMap;\r\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\r\n            let startIndex = sectionI * chunksPerSection;\r\n            let endIndex = startIndex + chunksPerSection;\r\n            scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1); // use the filtered\r\n        }\r\n        for (let col = 0; col < chunksPerSection; col += 1) {\r\n            scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection); // DON'T use the filtered\r\n        }\r\n        this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);\r\n        this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);\r\n    }\r\n    destroyScrollSyncers() {\r\n        mapHash(this.scrollSyncersBySection, destroyScrollSyncer);\r\n        mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);\r\n    }\r\n    getChunkConfigByIndex(index) {\r\n        let chunksPerSection = this.getDims()[1];\r\n        let sectionI = Math.floor(index / chunksPerSection);\r\n        let chunkI = index % chunksPerSection;\r\n        let sectionConfig = this.props.sections[sectionI];\r\n        return sectionConfig && sectionConfig.chunks[chunkI];\r\n    }\r\n    forceScrollLeft(col, scrollLeft) {\r\n        let scrollSyncer = this.scrollSyncersByColumn[col];\r\n        if (scrollSyncer) {\r\n            scrollSyncer.forceScrollLeft(scrollLeft);\r\n        }\r\n    }\r\n    forceScrollTop(sectionI, scrollTop) {\r\n        let scrollSyncer = this.scrollSyncersBySection[sectionI];\r\n        if (scrollSyncer) {\r\n            scrollSyncer.forceScrollTop(scrollTop);\r\n        }\r\n    }\r\n    _handleChunkEl(chunkEl, key) {\r\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\r\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\r\n            setRef(chunkConfig.elRef, chunkEl);\r\n        }\r\n    }\r\n    _handleScrollerEl(scrollerEl, key) {\r\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\r\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\r\n            setRef(chunkConfig.scrollerElRef, scrollerEl);\r\n        }\r\n    }\r\n    getDims() {\r\n        let sectionCnt = this.props.sections.length;\r\n        let chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;\r\n        return [sectionCnt, chunksPerSection];\r\n    }\r\n}\r\nScrollGrid.addStateEquality({\r\n    shrinkWidths: isArraysEqual,\r\n    scrollerClientWidths: isPropsEqual,\r\n    scrollerClientHeights: isPropsEqual,\r\n});\r\nfunction sumNumbers(numbers) {\r\n    let sum = 0;\r\n    for (let n of numbers) {\r\n        sum += n;\r\n    }\r\n    return sum;\r\n}\r\nfunction getRowInnerMaxHeight(rowEl) {\r\n    let innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight);\r\n    if (innerHeights.length) {\r\n        return Math.max(...innerHeights);\r\n    }\r\n    return 0;\r\n}\r\nfunction getElHeight(el) {\r\n    return el.offsetHeight; // better to deal with integers, for rounding, for PureComponent\r\n}\r\nfunction renderMacroColGroup(colGroupStats, shrinkWidths) {\r\n    let children = colGroupStats.map((colGroupStat, i) => {\r\n        let width = colGroupStat.width;\r\n        if (width === 'shrink') {\r\n            width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1; // +1 for border :(\r\n        }\r\n        return ( // eslint-disable-next-line react/jsx-key\r\n        createElement(\"col\", { style: { width } }));\r\n    });\r\n    return createElement('colgroup', {}, ...children);\r\n}\r\nfunction compileColGroupStat(colGroupConfig) {\r\n    let totalColWidth = sumColProp(colGroupConfig.cols, 'width'); // excludes \"shrink\"\r\n    let totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth');\r\n    let hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);\r\n    let allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);\r\n    return {\r\n        hasShrinkCol,\r\n        totalColWidth,\r\n        totalColMinWidth,\r\n        allowXScrolling,\r\n        cols: colGroupConfig.cols,\r\n        width: colGroupConfig.width,\r\n    };\r\n}\r\nfunction sumColProp(cols, propName) {\r\n    let total = 0;\r\n    for (let col of cols) {\r\n        let val = col[propName];\r\n        if (typeof val === 'number') {\r\n            total += val * (col.span || 1);\r\n        }\r\n    }\r\n    return total;\r\n}\r\nconst COL_GROUP_STAT_EQUALITY = {\r\n    cols: isColPropsEqual,\r\n};\r\nfunction isColGroupStatsEqual(stat0, stat1) {\r\n    return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);\r\n}\r\n// for memoizers...\r\nfunction initScrollSyncer(isVertical, ...scrollEls) {\r\n    return new ScrollSyncer(isVertical, scrollEls);\r\n}\r\nfunction destroyScrollSyncer(scrollSyncer) {\r\n    scrollSyncer.destroy();\r\n}\r\nfunction initStickyScrolling(scrollEl, isRtl) {\r\n    return new StickyScrolling(scrollEl, isRtl);\r\n}\r\n\r\nexport { ScrollGrid };\r\n", "import { config, createFormatter, greatestDurationDenominator, asCleanDays, createDuration, wholeDivideDurations, asRoughMs, addDays, startOfDay, asRoughSeconds, asRoughMinutes, diffWholeDays, isInt, computeVisibleDayRange, padStart, BaseComponent, memoizeObjArg, memoize, getDateMeta, ContentContainer, getSlotClassNames, getDayClassNames, buildNavLinkAttrs, PositionCache, findDirectChildren, rangeContainsMarker, NowTimer, NowIndicatorContainer, findElements, RefMap, multiplyDuration, SegHierarchy, groupIntersectingEntries, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, getSegMeta, renderFill, Slicer, intersectRanges, addMs, StandardEvent, MoreLinkContainer, sortEventSegs, mapHash, isPropsEqual, DateComponent, getStickyHeaderDates, getStickyFooterScrollbar, ViewContainer, renderScrollShim, injectStyles } from '@fullcalendar/core/internal.js';\r\nimport { createElement, Fragment, createRef } from '@fullcalendar/core/preact.js';\r\nimport { ScrollGrid } from '@fullcalendar/scrollgrid/internal.js';\r\n\r\nconst MIN_AUTO_LABELS = 18; // more than `12` months but less that `24` hours\r\nconst MAX_AUTO_SLOTS_PER_LABEL = 6; // allows 6 10-min slots in an hour\r\nconst MAX_AUTO_CELLS = 200; // allows 4-days to have a :30 slot duration\r\nconfig.MAX_TIMELINE_SLOTS = 1000;\r\n// potential nice values for slot-duration and interval-duration\r\nconst STOCK_SUB_DURATIONS = [\r\n    { years: 1 },\r\n    { months: 1 },\r\n    { days: 1 },\r\n    { hours: 1 },\r\n    { minutes: 30 },\r\n    { minutes: 15 },\r\n    { minutes: 10 },\r\n    { minutes: 5 },\r\n    { minutes: 1 },\r\n    { seconds: 30 },\r\n    { seconds: 15 },\r\n    { seconds: 10 },\r\n    { seconds: 5 },\r\n    { seconds: 1 },\r\n    { milliseconds: 500 },\r\n    { milliseconds: 100 },\r\n    { milliseconds: 10 },\r\n    { milliseconds: 1 },\r\n];\r\nfunction buildTimelineDateProfile(dateProfile, dateEnv, allOptions, dateProfileGenerator) {\r\n    let tDateProfile = {\r\n        labelInterval: allOptions.slotLabelInterval,\r\n        slotDuration: allOptions.slotDuration,\r\n    };\r\n    validateLabelAndSlot(tDateProfile, dateProfile, dateEnv); // validate after computed grid duration\r\n    ensureLabelInterval(tDateProfile, dateProfile, dateEnv);\r\n    ensureSlotDuration(tDateProfile, dateProfile, dateEnv);\r\n    let input = allOptions.slotLabelFormat;\r\n    let rawFormats = Array.isArray(input) ? input :\r\n        (input != null) ? [input] :\r\n            computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions);\r\n    tDateProfile.headerFormats = rawFormats.map((rawFormat) => createFormatter(rawFormat));\r\n    tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);\r\n    let largeUnit = null;\r\n    if (!tDateProfile.isTimeScale) {\r\n        const slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\r\n        if (/year|month|week/.test(slotUnit)) {\r\n            largeUnit = slotUnit;\r\n        }\r\n    }\r\n    tDateProfile.largeUnit = largeUnit;\r\n    tDateProfile.emphasizeWeeks =\r\n        asCleanDays(tDateProfile.slotDuration) === 1 &&\r\n            currentRangeAs('weeks', dateProfile, dateEnv) >= 2 &&\r\n            !allOptions.businessHours;\r\n    /*\r\n    console.log('label interval =', timelineView.labelInterval.humanize())\r\n    console.log('slot duration =', timelineView.slotDuration.humanize())\r\n    console.log('header formats =', timelineView.headerFormats)\r\n    console.log('isTimeScale', timelineView.isTimeScale)\r\n    console.log('largeUnit', timelineView.largeUnit)\r\n    */\r\n    let rawSnapDuration = allOptions.snapDuration;\r\n    let snapDuration;\r\n    let snapsPerSlot;\r\n    if (rawSnapDuration) {\r\n        snapDuration = createDuration(rawSnapDuration);\r\n        snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration);\r\n        // ^ TODO: warning if not whole?\r\n    }\r\n    if (snapsPerSlot == null) {\r\n        snapDuration = tDateProfile.slotDuration;\r\n        snapsPerSlot = 1;\r\n    }\r\n    tDateProfile.snapDuration = snapDuration;\r\n    tDateProfile.snapsPerSlot = snapsPerSlot;\r\n    // more...\r\n    let timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime);\r\n    // TODO: why not use normalizeRange!?\r\n    let normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);\r\n    let normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv);\r\n    // apply slotMinTime/slotMaxTime\r\n    // TODO: View should be responsible.\r\n    if (tDateProfile.isTimeScale) {\r\n        normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime);\r\n        normalizedEnd = dateEnv.add(addDays(normalizedEnd, -1), dateProfile.slotMaxTime);\r\n    }\r\n    tDateProfile.timeWindowMs = timeWindowMs;\r\n    tDateProfile.normalizedRange = { start: normalizedStart, end: normalizedEnd };\r\n    let slotDates = [];\r\n    let date = normalizedStart;\r\n    while (date < normalizedEnd) {\r\n        if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\r\n            slotDates.push(date);\r\n        }\r\n        date = dateEnv.add(date, tDateProfile.slotDuration);\r\n    }\r\n    tDateProfile.slotDates = slotDates;\r\n    // more...\r\n    let snapIndex = -1;\r\n    let snapDiff = 0; // index of the diff :(\r\n    const snapDiffToIndex = [];\r\n    const snapIndexToDiff = [];\r\n    date = normalizedStart;\r\n    while (date < normalizedEnd) {\r\n        if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\r\n            snapIndex += 1;\r\n            snapDiffToIndex.push(snapIndex);\r\n            snapIndexToDiff.push(snapDiff);\r\n        }\r\n        else {\r\n            snapDiffToIndex.push(snapIndex + 0.5);\r\n        }\r\n        date = dateEnv.add(date, tDateProfile.snapDuration);\r\n        snapDiff += 1;\r\n    }\r\n    tDateProfile.snapDiffToIndex = snapDiffToIndex;\r\n    tDateProfile.snapIndexToDiff = snapIndexToDiff;\r\n    tDateProfile.snapCnt = snapIndex + 1; // is always one behind\r\n    tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot;\r\n    // more...\r\n    tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);\r\n    tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv);\r\n    tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\r\n    return tDateProfile;\r\n}\r\n/*\r\nsnaps to appropriate unit\r\n*/\r\nfunction normalizeDate(date, tDateProfile, dateEnv) {\r\n    let normalDate = date;\r\n    if (!tDateProfile.isTimeScale) {\r\n        normalDate = startOfDay(normalDate);\r\n        if (tDateProfile.largeUnit) {\r\n            normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);\r\n        }\r\n    }\r\n    return normalDate;\r\n}\r\n/*\r\nsnaps to appropriate unit\r\n*/\r\nfunction normalizeRange(range, tDateProfile, dateEnv) {\r\n    if (!tDateProfile.isTimeScale) {\r\n        range = computeVisibleDayRange(range);\r\n        if (tDateProfile.largeUnit) {\r\n            let dayRange = range; // preserve original result\r\n            range = {\r\n                start: dateEnv.startOf(range.start, tDateProfile.largeUnit),\r\n                end: dateEnv.startOf(range.end, tDateProfile.largeUnit),\r\n            };\r\n            // if date is partially through the interval, or is in the same interval as the start,\r\n            // make the exclusive end be the *next* interval\r\n            if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {\r\n                range = {\r\n                    start: range.start,\r\n                    end: dateEnv.add(range.end, tDateProfile.slotDuration),\r\n                };\r\n            }\r\n        }\r\n    }\r\n    return range;\r\n}\r\nfunction isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator) {\r\n    if (dateProfileGenerator.isHiddenDay(date)) {\r\n        return false;\r\n    }\r\n    if (tDateProfile.isTimeScale) {\r\n        // determine if the time is within slotMinTime/slotMaxTime, which may have wacky values\r\n        let day = startOfDay(date);\r\n        let timeMs = date.valueOf() - day.valueOf();\r\n        let ms = timeMs - asRoughMs(dateProfile.slotMinTime); // milliseconds since slotMinTime\r\n        ms = ((ms % 86400000) + 86400000) % 86400000; // make negative values wrap to 24hr clock\r\n        return ms < tDateProfile.timeWindowMs; // before the slotMaxTime?\r\n    }\r\n    return true;\r\n}\r\nfunction validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {\r\n    const { currentRange } = dateProfile;\r\n    // make sure labelInterval doesn't exceed the max number of cells\r\n    if (tDateProfile.labelInterval) {\r\n        const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);\r\n        if (labelCnt > config.MAX_TIMELINE_SLOTS) {\r\n            console.warn('slotLabelInterval results in too many cells');\r\n            tDateProfile.labelInterval = null;\r\n        }\r\n    }\r\n    // make sure slotDuration doesn't exceed the maximum number of cells\r\n    if (tDateProfile.slotDuration) {\r\n        const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);\r\n        if (slotCnt > config.MAX_TIMELINE_SLOTS) {\r\n            console.warn('slotDuration results in too many cells');\r\n            tDateProfile.slotDuration = null;\r\n        }\r\n    }\r\n    // make sure labelInterval is a multiple of slotDuration\r\n    if (tDateProfile.labelInterval && tDateProfile.slotDuration) {\r\n        const slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\r\n        if (slotsPerLabel === null || slotsPerLabel < 1) {\r\n            console.warn('slotLabelInterval must be a multiple of slotDuration');\r\n            tDateProfile.slotDuration = null;\r\n        }\r\n    }\r\n}\r\nfunction ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {\r\n    const { currentRange } = dateProfile;\r\n    let { labelInterval } = tDateProfile;\r\n    if (!labelInterval) {\r\n        // compute based off the slot duration\r\n        // find the largest label interval with an acceptable slots-per-label\r\n        let input;\r\n        if (tDateProfile.slotDuration) {\r\n            for (input of STOCK_SUB_DURATIONS) {\r\n                const tryLabelInterval = createDuration(input);\r\n                const slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);\r\n                if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\r\n                    labelInterval = tryLabelInterval;\r\n                    break;\r\n                }\r\n            }\r\n            // use the slot duration as a last resort\r\n            if (!labelInterval) {\r\n                labelInterval = tDateProfile.slotDuration;\r\n            }\r\n            // compute based off the view's duration\r\n            // find the largest label interval that yields the minimum number of labels\r\n        }\r\n        else {\r\n            for (input of STOCK_SUB_DURATIONS) {\r\n                labelInterval = createDuration(input);\r\n                const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);\r\n                if (labelCnt >= MIN_AUTO_LABELS) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        tDateProfile.labelInterval = labelInterval;\r\n    }\r\n    return labelInterval;\r\n}\r\nfunction ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {\r\n    const { currentRange } = dateProfile;\r\n    let { slotDuration } = tDateProfile;\r\n    if (!slotDuration) {\r\n        const labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv); // will compute if necessary\r\n        // compute based off the label interval\r\n        // find the largest slot duration that is different from labelInterval, but still acceptable\r\n        for (let input of STOCK_SUB_DURATIONS) {\r\n            const trySlotDuration = createDuration(input);\r\n            const slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration);\r\n            if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\r\n                slotDuration = trySlotDuration;\r\n                break;\r\n            }\r\n        }\r\n        // only allow the value if it won't exceed the view's # of slots limit\r\n        if (slotDuration) {\r\n            const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);\r\n            if (slotCnt > MAX_AUTO_CELLS) {\r\n                slotDuration = null;\r\n            }\r\n        }\r\n        // use the label interval as a last resort\r\n        if (!slotDuration) {\r\n            slotDuration = labelInterval;\r\n        }\r\n        tDateProfile.slotDuration = slotDuration;\r\n    }\r\n    return slotDuration;\r\n}\r\nfunction computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions) {\r\n    let format1;\r\n    let format2;\r\n    const { labelInterval } = tDateProfile;\r\n    let unit = greatestDurationDenominator(labelInterval).unit;\r\n    const weekNumbersVisible = allOptions.weekNumbers;\r\n    let format0 = (format1 = (format2 = null));\r\n    // NOTE: weekNumber computation function wont work\r\n    if ((unit === 'week') && !weekNumbersVisible) {\r\n        unit = 'day';\r\n    }\r\n    switch (unit) {\r\n        case 'year':\r\n            format0 = { year: 'numeric' }; // '2015'\r\n            break;\r\n        case 'month':\r\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\r\n                format0 = { year: 'numeric' }; // '2015'\r\n            }\r\n            format1 = { month: 'short' }; // 'Jan'\r\n            break;\r\n        case 'week':\r\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\r\n                format0 = { year: 'numeric' }; // '2015'\r\n            }\r\n            format1 = { week: 'narrow' }; // 'Wk4'\r\n            break;\r\n        case 'day':\r\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\r\n                format0 = { year: 'numeric', month: 'long' }; // 'January 2014'\r\n            }\r\n            else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {\r\n                format0 = { month: 'long' }; // 'January'\r\n            }\r\n            if (weekNumbersVisible) {\r\n                format1 = { week: 'short' }; // 'Wk 4'\r\n            }\r\n            format2 = { weekday: 'narrow', day: 'numeric' }; // 'Su 9'\r\n            break;\r\n        case 'hour':\r\n            if (weekNumbersVisible) {\r\n                format0 = { week: 'short' }; // 'Wk 4'\r\n            }\r\n            if (currentRangeAs('days', dateProfile, dateEnv) > 1) {\r\n                format1 = { weekday: 'short', day: 'numeric', month: 'numeric', omitCommas: true }; // Sat 4/7\r\n            }\r\n            format2 = {\r\n                hour: 'numeric',\r\n                minute: '2-digit',\r\n                omitZeroMinute: true,\r\n                meridiem: 'short',\r\n            };\r\n            break;\r\n        case 'minute':\r\n            // sufficiently large number of different minute cells?\r\n            if ((asRoughMinutes(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\r\n                format0 = {\r\n                    hour: 'numeric',\r\n                    meridiem: 'short',\r\n                };\r\n                format1 = (params) => (':' + padStart(params.date.minute, 2) // ':30'\r\n                );\r\n            }\r\n            else {\r\n                format0 = {\r\n                    hour: 'numeric',\r\n                    minute: 'numeric',\r\n                    meridiem: 'short',\r\n                };\r\n            }\r\n            break;\r\n        case 'second':\r\n            // sufficiently large number of different second cells?\r\n            if ((asRoughSeconds(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\r\n                format0 = { hour: 'numeric', minute: '2-digit', meridiem: 'lowercase' }; // '8:30 PM'\r\n                format1 = (params) => (':' + padStart(params.date.second, 2) // ':30'\r\n                );\r\n            }\r\n            else {\r\n                format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' }; // '8:30:45 PM'\r\n            }\r\n            break;\r\n        case 'millisecond':\r\n            format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' }; // '8:30:45 PM'\r\n            format1 = (params) => ('.' + padStart(params.millisecond, 3));\r\n            break;\r\n    }\r\n    return [].concat(format0 || [], format1 || [], format2 || []);\r\n}\r\n// Compute the number of the give units in the \"current\" range.\r\n// Won't go more precise than days.\r\n// Will return `0` if there's not a clean whole interval.\r\nfunction currentRangeAs(unit, dateProfile, dateEnv) {\r\n    let range = dateProfile.currentRange;\r\n    let res = null;\r\n    if (unit === 'years') {\r\n        res = dateEnv.diffWholeYears(range.start, range.end);\r\n    }\r\n    else if (unit === 'months') {\r\n        res = dateEnv.diffWholeMonths(range.start, range.end);\r\n    }\r\n    else if (unit === 'weeks') {\r\n        res = dateEnv.diffWholeMonths(range.start, range.end);\r\n    }\r\n    else if (unit === 'days') {\r\n        res = diffWholeDays(range.start, range.end);\r\n    }\r\n    return res || 0;\r\n}\r\nfunction buildIsWeekStarts(tDateProfile, dateEnv) {\r\n    let { slotDates, emphasizeWeeks } = tDateProfile;\r\n    let prevWeekNumber = null;\r\n    let isWeekStarts = [];\r\n    for (let slotDate of slotDates) {\r\n        let weekNumber = dateEnv.computeWeekNumber(slotDate);\r\n        let isWeekStart = emphasizeWeeks && (prevWeekNumber !== null) && (prevWeekNumber !== weekNumber);\r\n        prevWeekNumber = weekNumber;\r\n        isWeekStarts.push(isWeekStart);\r\n    }\r\n    return isWeekStarts;\r\n}\r\nfunction buildCellRows(tDateProfile, dateEnv) {\r\n    let slotDates = tDateProfile.slotDates;\r\n    let formats = tDateProfile.headerFormats;\r\n    let cellRows = formats.map(() => []); // indexed by row,col\r\n    let slotAsDays = asCleanDays(tDateProfile.slotDuration);\r\n    let guessedSlotUnit = slotAsDays === 7 ? 'week' :\r\n        slotAsDays === 1 ? 'day' :\r\n            null;\r\n    // specifically for navclicks\r\n    let rowUnitsFromFormats = formats.map((format) => (format.getLargestUnit ? format.getLargestUnit() : null));\r\n    // builds cellRows and slotCells\r\n    for (let i = 0; i < slotDates.length; i += 1) {\r\n        let date = slotDates[i];\r\n        let isWeekStart = tDateProfile.isWeekStarts[i];\r\n        for (let row = 0; row < formats.length; row += 1) {\r\n            let format = formats[row];\r\n            let rowCells = cellRows[row];\r\n            let leadingCell = rowCells[rowCells.length - 1];\r\n            let isLastRow = row === formats.length - 1;\r\n            let isSuperRow = formats.length > 1 && !isLastRow; // more than one row and not the last\r\n            let newCell = null;\r\n            let rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null);\r\n            if (isSuperRow) {\r\n                let text = dateEnv.format(date, format);\r\n                if (!leadingCell || (leadingCell.text !== text)) {\r\n                    newCell = buildCellObject(date, text, rowUnit);\r\n                }\r\n                else {\r\n                    leadingCell.colspan += 1;\r\n                }\r\n            }\r\n            else if (!leadingCell ||\r\n                isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {\r\n                let text = dateEnv.format(date, format);\r\n                newCell = buildCellObject(date, text, rowUnit);\r\n            }\r\n            else {\r\n                leadingCell.colspan += 1;\r\n            }\r\n            if (newCell) {\r\n                newCell.weekStart = isWeekStart;\r\n                rowCells.push(newCell);\r\n            }\r\n        }\r\n    }\r\n    return cellRows;\r\n}\r\nfunction buildCellObject(date, text, rowUnit) {\r\n    return { date, text, rowUnit, colspan: 1, isWeekStart: false };\r\n}\r\n\r\nclass TimelineHeaderTh extends BaseComponent {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.refineRenderProps = memoizeObjArg(refineRenderProps);\r\n        this.buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs);\r\n    }\r\n    render() {\r\n        let { props, context } = this;\r\n        let { dateEnv, options } = context;\r\n        let { cell, dateProfile, tDateProfile } = props;\r\n        // the cell.rowUnit is f'd\r\n        // giving 'month' for a 3-day view\r\n        // workaround: to infer day, do NOT time\r\n        let dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile);\r\n        let renderProps = this.refineRenderProps({\r\n            level: props.rowLevel,\r\n            dateMarker: cell.date,\r\n            text: cell.text,\r\n            dateEnv: context.dateEnv,\r\n            viewApi: context.viewApi,\r\n        });\r\n        return (createElement(ContentContainer, { elTag: \"th\", elClasses: [\r\n                'fc-timeline-slot',\r\n                'fc-timeline-slot-label',\r\n                cell.isWeekStart && 'fc-timeline-slot-em',\r\n                ...( // TODO: so slot classnames for week/month/bigger. see note above about rowUnit\r\n                cell.rowUnit === 'time' ?\r\n                    getSlotClassNames(dateMeta, context.theme) :\r\n                    getDayClassNames(dateMeta, context.theme)),\r\n            ], elAttrs: {\r\n                colSpan: cell.colspan,\r\n                'data-date': dateEnv.formatIso(cell.date, {\r\n                    omitTime: !tDateProfile.isTimeScale,\r\n                    omitTimeZoneOffset: true,\r\n                }),\r\n            }, renderProps: renderProps, generatorName: \"slotLabelContent\", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => (createElement(\"div\", { className: \"fc-timeline-slot-frame\", style: { height: props.rowInnerHeight } },\r\n            createElement(InnerContent, { elTag: \"a\", elClasses: [\r\n                    'fc-timeline-slot-cushion',\r\n                    'fc-scrollgrid-sync-inner',\r\n                    props.isSticky && 'fc-sticky',\r\n                ], elAttrs: this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit) })))));\r\n    }\r\n}\r\nfunction buildCellNavLinkAttrs(context, cellDate, rowUnit) {\r\n    return (rowUnit && rowUnit !== 'time')\r\n        ? buildNavLinkAttrs(context, cellDate, rowUnit)\r\n        : {};\r\n}\r\nfunction renderInnerContent(renderProps) {\r\n    return renderProps.text;\r\n}\r\nfunction refineRenderProps(input) {\r\n    return {\r\n        level: input.level,\r\n        date: input.dateEnv.toDate(input.dateMarker),\r\n        view: input.viewApi,\r\n        text: input.text,\r\n    };\r\n}\r\n\r\nclass TimelineHeaderRows extends BaseComponent {\r\n    render() {\r\n        let { dateProfile, tDateProfile, rowInnerHeights, todayRange, nowDate } = this.props;\r\n        let { cellRows } = tDateProfile;\r\n        return (createElement(Fragment, null, cellRows.map((rowCells, rowLevel) => {\r\n            let isLast = rowLevel === cellRows.length - 1;\r\n            let isChrono = tDateProfile.isTimeScale && isLast; // the final row, with times?\r\n            let classNames = [\r\n                'fc-timeline-header-row',\r\n                isChrono ? 'fc-timeline-header-row-chrono' : '',\r\n            ];\r\n            return ( // eslint-disable-next-line react/no-array-index-key\r\n            createElement(\"tr\", { key: rowLevel, className: classNames.join(' ') }, rowCells.map((cell) => (createElement(TimelineHeaderTh, { key: cell.date.toISOString(), cell: cell, rowLevel: rowLevel, dateProfile: dateProfile, tDateProfile: tDateProfile, todayRange: todayRange, nowDate: nowDate, rowInnerHeight: rowInnerHeights && rowInnerHeights[rowLevel], isSticky: !isLast })))));\r\n        })));\r\n    }\r\n}\r\n\r\nclass TimelineCoords {\r\n    constructor(slatRootEl, // okay to expose?\r\n    slatEls, dateProfile, tDateProfile, dateEnv, isRtl) {\r\n        this.slatRootEl = slatRootEl;\r\n        this.dateProfile = dateProfile;\r\n        this.tDateProfile = tDateProfile;\r\n        this.dateEnv = dateEnv;\r\n        this.isRtl = isRtl;\r\n        this.outerCoordCache = new PositionCache(slatRootEl, slatEls, true, // isHorizontal\r\n        false);\r\n        // for the inner divs within the slats\r\n        // used for event rendering and scrollTime, to disregard slat border\r\n        this.innerCoordCache = new PositionCache(slatRootEl, findDirectChildren(slatEls, 'div'), true, // isHorizontal\r\n        false);\r\n    }\r\n    isDateInRange(date) {\r\n        return rangeContainsMarker(this.dateProfile.currentRange, date);\r\n    }\r\n    // results range from negative width of area to 0\r\n    dateToCoord(date) {\r\n        let { tDateProfile } = this;\r\n        let snapCoverage = this.computeDateSnapCoverage(date);\r\n        let slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;\r\n        let slotIndex = Math.floor(slotCoverage);\r\n        slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);\r\n        let partial = slotCoverage - slotIndex;\r\n        let { innerCoordCache, outerCoordCache } = this;\r\n        if (this.isRtl) {\r\n            return outerCoordCache.originClientRect.width - (outerCoordCache.rights[slotIndex] -\r\n                (innerCoordCache.getWidth(slotIndex) * partial));\r\n        }\r\n        return (outerCoordCache.lefts[slotIndex] +\r\n            (innerCoordCache.getWidth(slotIndex) * partial));\r\n    }\r\n    rangeToCoords(range) {\r\n        return {\r\n            start: this.dateToCoord(range.start),\r\n            end: this.dateToCoord(range.end),\r\n        };\r\n    }\r\n    durationToCoord(duration) {\r\n        let { dateProfile, tDateProfile, dateEnv, isRtl } = this;\r\n        let coord = 0;\r\n        if (dateProfile) {\r\n            let date = dateEnv.add(dateProfile.activeRange.start, duration);\r\n            if (!tDateProfile.isTimeScale) {\r\n                date = startOfDay(date);\r\n            }\r\n            coord = this.dateToCoord(date);\r\n            // hack to overcome the left borders of non-first slat\r\n            if (!isRtl && coord) {\r\n                coord += 1;\r\n            }\r\n        }\r\n        return coord;\r\n    }\r\n    coordFromLeft(coord) {\r\n        if (this.isRtl) {\r\n            return this.outerCoordCache.originClientRect.width - coord;\r\n        }\r\n        return coord;\r\n    }\r\n    // returned value is between 0 and the number of snaps\r\n    computeDateSnapCoverage(date) {\r\n        return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv);\r\n    }\r\n}\r\n// returned value is between 0 and the number of snaps\r\nfunction computeDateSnapCoverage(date, tDateProfile, dateEnv) {\r\n    let snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);\r\n    if (snapDiff < 0) {\r\n        return 0;\r\n    }\r\n    if (snapDiff >= tDateProfile.snapDiffToIndex.length) {\r\n        return tDateProfile.snapCnt;\r\n    }\r\n    let snapDiffInt = Math.floor(snapDiff);\r\n    let snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];\r\n    if (isInt(snapCoverage)) { // not an in-between value\r\n        snapCoverage += snapDiff - snapDiffInt; // add the remainder\r\n    }\r\n    else {\r\n        // a fractional value, meaning the date is not visible\r\n        // always round up in this case. works for start AND end dates in a range.\r\n        snapCoverage = Math.ceil(snapCoverage);\r\n    }\r\n    return snapCoverage;\r\n}\r\nfunction coordToCss(hcoord, isRtl) {\r\n    if (hcoord === null) {\r\n        return { left: '', right: '' };\r\n    }\r\n    if (isRtl) {\r\n        return { right: hcoord, left: '' };\r\n    }\r\n    return { left: hcoord, right: '' };\r\n}\r\nfunction coordsToCss(hcoords, isRtl) {\r\n    if (!hcoords) {\r\n        return { left: '', right: '' };\r\n    }\r\n    if (isRtl) {\r\n        return { right: hcoords.start, left: -hcoords.end };\r\n    }\r\n    return { left: hcoords.start, right: -hcoords.end };\r\n}\r\n\r\nclass TimelineHeader extends BaseComponent {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.rootElRef = createRef();\r\n    }\r\n    render() {\r\n        let { props, context } = this;\r\n        // TODO: very repetitive\r\n        // TODO: make part of tDateProfile?\r\n        let timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit;\r\n        // WORKAROUND: make ignore slatCoords when out of sync with dateProfile\r\n        let slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null;\r\n        return (createElement(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => (createElement(\"div\", { className: \"fc-timeline-header\", ref: this.rootElRef },\r\n            createElement(\"table\", { \"aria-hidden\": true, className: \"fc-scrollgrid-sync-table\", style: { minWidth: props.tableMinWidth, width: props.clientWidth } },\r\n                props.tableColGroupNode,\r\n                createElement(\"tbody\", null,\r\n                    createElement(TimelineHeaderRows, { dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: nowDate, todayRange: todayRange, rowInnerHeights: props.rowInnerHeights }))),\r\n            context.options.nowIndicator && (\r\n            // need to have a container regardless of whether the current view has a visible now indicator\r\n            // because apparently removal of the element resets the scroll for some reasons (issue #5351).\r\n            // this issue doesn't happen for the timeline body however (\r\n            createElement(\"div\", { className: \"fc-timeline-now-indicator-container\" }, (slatCoords && slatCoords.isDateInRange(nowDate)) && (createElement(NowIndicatorContainer, { elClasses: ['fc-timeline-now-indicator-arrow'], elStyle: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl), isAxis: true, date: nowDate }))))))));\r\n    }\r\n    componentDidMount() {\r\n        this.updateSize();\r\n    }\r\n    componentDidUpdate() {\r\n        this.updateSize();\r\n    }\r\n    updateSize() {\r\n        if (this.props.onMaxCushionWidth) {\r\n            this.props.onMaxCushionWidth(this.computeMaxCushionWidth());\r\n        }\r\n    }\r\n    computeMaxCushionWidth() {\r\n        return Math.max(...findElements(this.rootElRef.current, '.fc-timeline-header-row:last-child .fc-timeline-slot-cushion').map((el) => el.getBoundingClientRect().width));\r\n    }\r\n}\r\n\r\nclass TimelineSlatCell extends BaseComponent {\r\n    render() {\r\n        let { props, context } = this;\r\n        let { dateEnv, options, theme } = context;\r\n        let { date, tDateProfile, isEm } = props;\r\n        let dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile);\r\n        let renderProps = Object.assign(Object.assign({ date: dateEnv.toDate(props.date) }, dateMeta), { view: context.viewApi });\r\n        return (createElement(ContentContainer, { elTag: \"td\", elRef: props.elRef, elClasses: [\r\n                'fc-timeline-slot',\r\n                'fc-timeline-slot-lane',\r\n                isEm && 'fc-timeline-slot-em',\r\n                tDateProfile.isTimeScale ? (isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, props.date, tDateProfile.labelInterval)) ?\r\n                    'fc-timeline-slot-major' :\r\n                    'fc-timeline-slot-minor') : '',\r\n                ...(props.isDay ?\r\n                    getDayClassNames(dateMeta, theme) :\r\n                    getSlotClassNames(dateMeta, theme)),\r\n            ], elAttrs: {\r\n                'data-date': dateEnv.formatIso(date, {\r\n                    omitTimeZoneOffset: true,\r\n                    omitTime: !tDateProfile.isTimeScale,\r\n                }),\r\n            }, renderProps: renderProps, generatorName: \"slotLaneContent\", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount }, (InnerContent) => (createElement(InnerContent, { elTag: \"div\" }))));\r\n    }\r\n}\r\n\r\nclass TimelineSlatsBody extends BaseComponent {\r\n    render() {\r\n        let { props } = this;\r\n        let { tDateProfile, cellElRefs } = props;\r\n        let { slotDates, isWeekStarts } = tDateProfile;\r\n        let isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit;\r\n        return (createElement(\"tbody\", null,\r\n            createElement(\"tr\", null, slotDates.map((slotDate, i) => {\r\n                let key = slotDate.toISOString();\r\n                return (createElement(TimelineSlatCell, { key: key, elRef: cellElRefs.createRef(key), date: slotDate, dateProfile: props.dateProfile, tDateProfile: tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isEm: isWeekStarts[i], isDay: isDay }));\r\n            }))));\r\n    }\r\n}\r\n\r\nclass TimelineSlats extends BaseComponent {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.rootElRef = createRef();\r\n        this.cellElRefs = new RefMap();\r\n        this.handleScrollRequest = (request) => {\r\n            let { onScrollLeftRequest } = this.props;\r\n            let { coords } = this;\r\n            if (onScrollLeftRequest && coords) {\r\n                if (request.time) {\r\n                    let scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time));\r\n                    onScrollLeftRequest(scrollLeft);\r\n                }\r\n                return true;\r\n            }\r\n            return null; // best?\r\n        };\r\n    }\r\n    render() {\r\n        let { props, context } = this;\r\n        return (createElement(\"div\", { className: \"fc-timeline-slots\", ref: this.rootElRef },\r\n            createElement(\"table\", { \"aria-hidden\": true, className: context.theme.getClass('table'), style: {\r\n                    minWidth: props.tableMinWidth,\r\n                    width: props.clientWidth,\r\n                } },\r\n                props.tableColGroupNode,\r\n                createElement(TimelineSlatsBody, { cellElRefs: this.cellElRefs, dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange }))));\r\n    }\r\n    componentDidMount() {\r\n        this.updateSizing();\r\n        this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\r\n    }\r\n    componentDidUpdate(prevProps) {\r\n        this.updateSizing();\r\n        this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\r\n    }\r\n    componentWillUnmount() {\r\n        this.scrollResponder.detach();\r\n        if (this.props.onCoords) {\r\n            this.props.onCoords(null);\r\n        }\r\n    }\r\n    updateSizing() {\r\n        let { props, context } = this;\r\n        if (props.clientWidth !== null && // is sizing stable?\r\n            this.scrollResponder\r\n        // ^it's possible to have clientWidth immediately after mount (when returning from print view), but w/o scrollResponder\r\n        ) {\r\n            let rootEl = this.rootElRef.current;\r\n            if (rootEl.offsetWidth) { // not hidden by css\r\n                this.coords = new TimelineCoords(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates), props.dateProfile, props.tDateProfile, context.dateEnv, context.isRtl);\r\n                if (props.onCoords) {\r\n                    props.onCoords(this.coords);\r\n                }\r\n                this.scrollResponder.update(false); // TODO: wouldn't have to do this if coords were in state\r\n            }\r\n        }\r\n    }\r\n    positionToHit(leftPosition) {\r\n        let { outerCoordCache } = this.coords;\r\n        let { dateEnv, isRtl } = this.context;\r\n        let { tDateProfile } = this.props;\r\n        let slatIndex = outerCoordCache.leftToIndex(leftPosition);\r\n        if (slatIndex != null) {\r\n            // somewhat similar to what TimeGrid does. consolidate?\r\n            let slatWidth = outerCoordCache.getWidth(slatIndex);\r\n            let partial = isRtl ?\r\n                (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth :\r\n                (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;\r\n            let localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);\r\n            let start = dateEnv.add(tDateProfile.slotDates[slatIndex], multiplyDuration(tDateProfile.snapDuration, localSnapIndex));\r\n            let end = dateEnv.add(start, tDateProfile.snapDuration);\r\n            return {\r\n                dateSpan: {\r\n                    range: { start, end },\r\n                    allDay: !this.props.tDateProfile.isTimeScale,\r\n                },\r\n                dayEl: this.cellElRefs.currentMap[slatIndex],\r\n                left: outerCoordCache.lefts[slatIndex],\r\n                right: outerCoordCache.rights[slatIndex],\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n}\r\nfunction collectCellEls(elMap, slotDates) {\r\n    return slotDates.map((slotDate) => {\r\n        let key = slotDate.toISOString();\r\n        return elMap[key];\r\n    });\r\n}\r\n\r\nfunction computeSegHCoords(segs, minWidth, timelineCoords) {\r\n    let hcoords = [];\r\n    if (timelineCoords) {\r\n        for (let seg of segs) {\r\n            let res = timelineCoords.rangeToCoords(seg);\r\n            let start = Math.round(res.start); // for barely-overlapping collisions\r\n            let end = Math.round(res.end); //\r\n            if (end - start < minWidth) {\r\n                end = start + minWidth;\r\n            }\r\n            hcoords.push({ start, end });\r\n        }\r\n    }\r\n    return hcoords;\r\n}\r\nfunction computeFgSegPlacements(segs, segHCoords, // might not have for every seg\r\neventInstanceHeights, // might not have for every seg\r\nmoreLinkHeights, // might not have for every more-link\r\nstrictOrder, maxStackCnt) {\r\n    let segInputs = [];\r\n    let crudePlacements = []; // when we don't know dims\r\n    for (let i = 0; i < segs.length; i += 1) {\r\n        let seg = segs[i];\r\n        let instanceId = seg.eventRange.instance.instanceId;\r\n        let height = eventInstanceHeights[instanceId];\r\n        let hcoords = segHCoords[i];\r\n        if (height && hcoords) {\r\n            segInputs.push({\r\n                index: i,\r\n                span: hcoords,\r\n                thickness: height,\r\n            });\r\n        }\r\n        else {\r\n            crudePlacements.push({\r\n                seg,\r\n                hcoords,\r\n                top: null,\r\n            });\r\n        }\r\n    }\r\n    let hierarchy = new SegHierarchy();\r\n    if (strictOrder != null) {\r\n        hierarchy.strictOrder = strictOrder;\r\n    }\r\n    if (maxStackCnt != null) {\r\n        hierarchy.maxStackCnt = maxStackCnt;\r\n    }\r\n    let hiddenEntries = hierarchy.addSegs(segInputs);\r\n    let hiddenPlacements = hiddenEntries.map((entry) => ({\r\n        seg: segs[entry.index],\r\n        hcoords: entry.span,\r\n        top: null,\r\n    }));\r\n    let hiddenGroups = groupIntersectingEntries(hiddenEntries);\r\n    let moreLinkInputs = [];\r\n    let moreLinkCrudePlacements = [];\r\n    const extractSeg = (entry) => segs[entry.index];\r\n    for (let i = 0; i < hiddenGroups.length; i += 1) {\r\n        let hiddenGroup = hiddenGroups[i];\r\n        let sortedSegs = hiddenGroup.entries.map(extractSeg);\r\n        let height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))]; // not optimal :(\r\n        if (height != null) {\r\n            // NOTE: the hiddenGroup's spanStart/spanEnd are already computed by rangeToCoords. computed during input.\r\n            moreLinkInputs.push({\r\n                index: segs.length + i,\r\n                thickness: height,\r\n                span: hiddenGroup.span,\r\n            });\r\n        }\r\n        else {\r\n            moreLinkCrudePlacements.push({\r\n                seg: sortedSegs,\r\n                hcoords: hiddenGroup.span,\r\n                top: null,\r\n            });\r\n        }\r\n    }\r\n    // add more-links into the hierarchy, but don't limit\r\n    hierarchy.maxStackCnt = -1;\r\n    hierarchy.addSegs(moreLinkInputs);\r\n    let visibleRects = hierarchy.toRects();\r\n    let visiblePlacements = [];\r\n    let maxHeight = 0;\r\n    for (let rect of visibleRects) {\r\n        let segIndex = rect.index;\r\n        visiblePlacements.push({\r\n            seg: segIndex < segs.length\r\n                ? segs[segIndex] // a real seg\r\n                : hiddenGroups[segIndex - segs.length].entries.map(extractSeg),\r\n            hcoords: rect.span,\r\n            top: rect.levelCoord,\r\n        });\r\n        maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness);\r\n    }\r\n    return [\r\n        visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements),\r\n        maxHeight,\r\n    ];\r\n}\r\n\r\nclass TimelineLaneBg extends BaseComponent {\r\n    render() {\r\n        let { props } = this;\r\n        let highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs);\r\n        return props.timelineCoords && (createElement(\"div\", { className: \"fc-timeline-bg\" },\r\n            this.renderSegs(props.businessHourSegs || [], props.timelineCoords, 'non-business'),\r\n            this.renderSegs(props.bgEventSegs || [], props.timelineCoords, 'bg-event'),\r\n            this.renderSegs(highlightSeg, props.timelineCoords, 'highlight')));\r\n    }\r\n    renderSegs(segs, timelineCoords, fillType) {\r\n        let { todayRange, nowDate } = this.props;\r\n        let { isRtl } = this.context;\r\n        let segHCoords = computeSegHCoords(segs, 0, timelineCoords);\r\n        let children = segs.map((seg, i) => {\r\n            let hcoords = segHCoords[i];\r\n            let hStyle = coordsToCss(hcoords, isRtl);\r\n            return (createElement(\"div\", { key: buildEventRangeKey(seg.eventRange), className: \"fc-timeline-bg-harness\", style: hStyle }, fillType === 'bg-event' ?\r\n                createElement(BgEvent, Object.assign({ seg: seg }, getSegMeta(seg, todayRange, nowDate))) :\r\n                renderFill(fillType)));\r\n        });\r\n        return createElement(Fragment, null, children);\r\n    }\r\n}\r\n\r\nclass TimelineLaneSlicer extends Slicer {\r\n    sliceRange(origRange, dateProfile, dateProfileGenerator, tDateProfile, dateEnv) {\r\n        let normalRange = normalizeRange(origRange, tDateProfile, dateEnv);\r\n        let segs = [];\r\n        // protect against when the span is entirely in an invalid date region\r\n        if (computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv)\r\n            < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)) {\r\n            // intersect the footprint's range with the grid's range\r\n            let slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange);\r\n            if (slicedRange) {\r\n                segs.push({\r\n                    start: slicedRange.start,\r\n                    end: slicedRange.end,\r\n                    isStart: slicedRange.start.valueOf() === normalRange.start.valueOf()\r\n                        && isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),\r\n                    isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf()\r\n                        && isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator),\r\n                });\r\n            }\r\n        }\r\n        return segs;\r\n    }\r\n}\r\n\r\nconst DEFAULT_TIME_FORMAT = createFormatter({\r\n    hour: 'numeric',\r\n    minute: '2-digit',\r\n    omitZeroMinute: true,\r\n    meridiem: 'narrow',\r\n});\r\nclass TimelineEvent extends BaseComponent {\r\n    render() {\r\n        let { props } = this;\r\n        return (createElement(StandardEvent, Object.assign({}, props, { elClasses: ['fc-timeline-event', 'fc-h-event'], defaultTimeFormat: DEFAULT_TIME_FORMAT, defaultDisplayEventTime: !props.isTimeScale })));\r\n    }\r\n}\r\n\r\nclass TimelineLaneMoreLink extends BaseComponent {\r\n    render() {\r\n        let { props, context } = this;\r\n        let { hiddenSegs, placement, resourceId } = props;\r\n        let { top, hcoords } = placement;\r\n        let isVisible = hcoords && top !== null;\r\n        let hStyle = coordsToCss(hcoords, context.isRtl);\r\n        let extraDateSpan = resourceId ? { resourceId } : {};\r\n        return (createElement(MoreLinkContainer, { elRef: props.elRef, elClasses: ['fc-timeline-more-link'], elStyle: Object.assign({ visibility: isVisible ? '' : 'hidden', top: top || 0 }, hStyle), allDayDate: null, moreCnt: hiddenSegs.length, allSegs: hiddenSegs, hiddenSegs: hiddenSegs, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: extraDateSpan, popoverContent: () => (createElement(Fragment, null, hiddenSegs.map((seg) => {\r\n                let instanceId = seg.eventRange.instance.instanceId;\r\n                return (createElement(\"div\", { key: instanceId, style: { visibility: props.isForcedInvisible[instanceId] ? 'hidden' : '' } },\r\n                    createElement(TimelineEvent, Object.assign({ isTimeScale: props.isTimeScale, seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection }, getSegMeta(seg, props.todayRange, props.nowDate)))));\r\n            }))) }, (InnerContent) => (createElement(InnerContent, { elTag: \"div\", elClasses: ['fc-timeline-more-link-inner', 'fc-sticky'] }))));\r\n    }\r\n}\r\n\r\nclass TimelineLane extends BaseComponent {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.slicer = new TimelineLaneSlicer();\r\n        this.sortEventSegs = memoize(sortEventSegs);\r\n        this.harnessElRefs = new RefMap();\r\n        this.moreElRefs = new RefMap();\r\n        this.innerElRef = createRef();\r\n        // TODO: memoize event positioning\r\n        this.state = {\r\n            eventInstanceHeights: {},\r\n            moreLinkHeights: {},\r\n        };\r\n        this.handleResize = (isForced) => {\r\n            if (isForced) {\r\n                this.updateSize();\r\n            }\r\n        };\r\n    }\r\n    render() {\r\n        let { props, state, context } = this;\r\n        let { options } = context;\r\n        let { dateProfile, tDateProfile } = props;\r\n        let slicedProps = this.slicer.sliceProps(props, dateProfile, tDateProfile.isTimeScale ? null : props.nextDayThreshold, context, // wish we didn't have to pass in the rest of the args...\r\n        dateProfile, context.dateProfileGenerator, tDateProfile, context.dateEnv);\r\n        let mirrorSegs = (slicedProps.eventDrag ? slicedProps.eventDrag.segs : null) ||\r\n            (slicedProps.eventResize ? slicedProps.eventResize.segs : null) ||\r\n            [];\r\n        let fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder);\r\n        let fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords);\r\n        let [fgPlacements, fgHeight] = computeFgSegPlacements(fgSegs, fgSegHCoords, state.eventInstanceHeights, state.moreLinkHeights, options.eventOrderStrict, options.eventMaxStack);\r\n        let isForcedInvisible = // TODO: more convenient\r\n         (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) ||\r\n            (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) ||\r\n            {};\r\n        return (createElement(Fragment, null,\r\n            createElement(TimelineLaneBg, { businessHourSegs: slicedProps.businessHourSegs, bgEventSegs: slicedProps.bgEventSegs, timelineCoords: props.timelineCoords, eventResizeSegs: slicedProps.eventResize ? slicedProps.eventResize.segs : [] /* bad new empty array? */, dateSelectionSegs: slicedProps.dateSelectionSegs, nowDate: props.nowDate, todayRange: props.todayRange }),\r\n            createElement(\"div\", { className: \"fc-timeline-events fc-scrollgrid-sync-inner\", ref: this.innerElRef, style: { height: fgHeight } },\r\n                this.renderFgSegs(fgPlacements, isForcedInvisible, false, false, false),\r\n                this.renderFgSegs(buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements), {}, Boolean(slicedProps.eventDrag), Boolean(slicedProps.eventResize), false))));\r\n    }\r\n    componentDidMount() {\r\n        this.updateSize();\r\n        this.context.addResizeHandler(this.handleResize);\r\n    }\r\n    componentDidUpdate(prevProps, prevState) {\r\n        if (prevProps.eventStore !== this.props.eventStore || // external thing changed?\r\n            prevProps.timelineCoords !== this.props.timelineCoords || // external thing changed?\r\n            prevState.moreLinkHeights !== this.state.moreLinkHeights // HACK. see addStateEquality\r\n        ) {\r\n            this.updateSize();\r\n        }\r\n    }\r\n    componentWillUnmount() {\r\n        this.context.removeResizeHandler(this.handleResize);\r\n    }\r\n    updateSize() {\r\n        let { props } = this;\r\n        let { timelineCoords } = props;\r\n        const innerEl = this.innerElRef.current;\r\n        if (props.onHeightChange) {\r\n            props.onHeightChange(innerEl, false);\r\n        }\r\n        if (timelineCoords) {\r\n            this.setState({\r\n                eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, (harnessEl) => (Math.round(harnessEl.getBoundingClientRect().height))),\r\n                moreLinkHeights: mapHash(this.moreElRefs.currentMap, (moreEl) => (Math.round(moreEl.getBoundingClientRect().height))),\r\n            }, () => {\r\n                if (props.onHeightChange) {\r\n                    props.onHeightChange(innerEl, true);\r\n                }\r\n            });\r\n        }\r\n        // hack\r\n        if (props.syncParentMinHeight) {\r\n            innerEl.parentElement.style.minHeight = innerEl.style.height;\r\n        }\r\n    }\r\n    renderFgSegs(segPlacements, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\r\n        let { harnessElRefs, moreElRefs, props, context } = this;\r\n        let isMirror = isDragging || isResizing || isDateSelecting;\r\n        return (createElement(Fragment, null, segPlacements.map((segPlacement) => {\r\n            let { seg, hcoords, top } = segPlacement;\r\n            if (Array.isArray(seg)) { // a more-link\r\n                let isoStr = buildIsoString(computeEarliestSegStart(seg));\r\n                return (createElement(TimelineLaneMoreLink, { key: 'm:' + isoStr /* \"m\" for \"more\" */, elRef: moreElRefs.createRef(isoStr), hiddenSegs: seg, placement: segPlacement, dateProfile: props.dateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isTimeScale: props.tDateProfile.isTimeScale, eventSelection: props.eventSelection, resourceId: props.resourceId, isForcedInvisible: isForcedInvisible }));\r\n            }\r\n            let instanceId = seg.eventRange.instance.instanceId;\r\n            let isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null);\r\n            let hStyle = coordsToCss(hcoords, context.isRtl);\r\n            return (createElement(\"div\", { key: 'e:' + instanceId /* \"e\" for \"event\" */, ref: isMirror ? null : harnessElRefs.createRef(instanceId), className: \"fc-timeline-event-harness\", style: Object.assign({ visibility: isVisible ? '' : 'hidden', top: top || 0 }, hStyle) },\r\n                createElement(TimelineEvent, Object.assign({ isTimeScale: props.tDateProfile.isTimeScale, seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === props.eventSelection /* TODO: bad for mirror? */ }, getSegMeta(seg, props.todayRange, props.nowDate)))));\r\n        })));\r\n    }\r\n}\r\nTimelineLane.addStateEquality({\r\n    eventInstanceHeights: isPropsEqual,\r\n    moreLinkHeights: isPropsEqual,\r\n});\r\nfunction buildMirrorPlacements(mirrorSegs, timelineCoords, fgPlacements) {\r\n    if (!mirrorSegs.length || !timelineCoords) {\r\n        return [];\r\n    }\r\n    let topsByInstanceId = buildAbsoluteTopHash(fgPlacements); // TODO: cache this at first render?\r\n    return mirrorSegs.map((seg) => ({\r\n        seg,\r\n        hcoords: timelineCoords.rangeToCoords(seg),\r\n        top: topsByInstanceId[seg.eventRange.instance.instanceId],\r\n    }));\r\n}\r\nfunction buildAbsoluteTopHash(placements) {\r\n    let topsByInstanceId = {};\r\n    for (let placement of placements) {\r\n        let { seg } = placement;\r\n        if (!Array.isArray(seg)) { // doesn't represent a more-link\r\n            topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top;\r\n        }\r\n    }\r\n    return topsByInstanceId;\r\n}\r\n\r\nclass TimelineGrid extends DateComponent {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.slatsRef = createRef();\r\n        this.state = {\r\n            coords: null,\r\n        };\r\n        this.handeEl = (el) => {\r\n            if (el) {\r\n                this.context.registerInteractiveComponent(this, { el });\r\n            }\r\n            else {\r\n                this.context.unregisterInteractiveComponent(this);\r\n            }\r\n        };\r\n        this.handleCoords = (coords) => {\r\n            this.setState({ coords });\r\n            if (this.props.onSlatCoords) {\r\n                this.props.onSlatCoords(coords);\r\n            }\r\n        };\r\n    }\r\n    render() {\r\n        let { props, state, context } = this;\r\n        let { options } = context;\r\n        let { dateProfile, tDateProfile } = props;\r\n        let timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\r\n        return (createElement(\"div\", { className: \"fc-timeline-body\", ref: this.handeEl, style: {\r\n                minWidth: props.tableMinWidth,\r\n                height: props.clientHeight,\r\n                width: props.clientWidth,\r\n            } },\r\n            createElement(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => (createElement(Fragment, null,\r\n                createElement(TimelineSlats, { ref: this.slatsRef, dateProfile: dateProfile, tDateProfile: tDateProfile, nowDate: nowDate, todayRange: todayRange, clientWidth: props.clientWidth, tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, onCoords: this.handleCoords, onScrollLeftRequest: props.onScrollLeftRequest }),\r\n                createElement(TimelineLane, { dateProfile: dateProfile, tDateProfile: props.tDateProfile, nowDate: nowDate, todayRange: todayRange, nextDayThreshold: options.nextDayThreshold, businessHours: props.businessHours, eventStore: props.eventStore, eventUiBases: props.eventUiBases, dateSelection: props.dateSelection, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, timelineCoords: state.coords, syncParentMinHeight: true }),\r\n                (options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate)) && (createElement(\"div\", { className: \"fc-timeline-now-indicator-container\" },\r\n                    createElement(NowIndicatorContainer, { elClasses: ['fc-timeline-now-indicator-line'], elStyle: coordToCss(state.coords.dateToCoord(nowDate), context.isRtl), isAxis: false, date: nowDate }))))))));\r\n    }\r\n    // Hit System\r\n    // ------------------------------------------------------------------------------------------\r\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\r\n        let slats = this.slatsRef.current;\r\n        let slatHit = slats.positionToHit(positionLeft);\r\n        if (slatHit) {\r\n            return {\r\n                dateProfile: this.props.dateProfile,\r\n                dateSpan: slatHit.dateSpan,\r\n                rect: {\r\n                    left: slatHit.left,\r\n                    right: slatHit.right,\r\n                    top: 0,\r\n                    bottom: elHeight,\r\n                },\r\n                dayEl: slatHit.dayEl,\r\n                layer: 0,\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nclass TimelineView extends DateComponent {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);\r\n        this.scrollGridRef = createRef();\r\n        this.state = {\r\n            slatCoords: null,\r\n            slotCushionMaxWidth: null,\r\n        };\r\n        this.handleSlatCoords = (slatCoords) => {\r\n            this.setState({ slatCoords });\r\n        };\r\n        this.handleScrollLeftRequest = (scrollLeft) => {\r\n            let scrollGrid = this.scrollGridRef.current;\r\n            scrollGrid.forceScrollLeft(0, scrollLeft);\r\n        };\r\n        this.handleMaxCushionWidth = (slotCushionMaxWidth) => {\r\n            this.setState({\r\n                slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth), // for less rerendering TODO: DRY\r\n            });\r\n        };\r\n    }\r\n    render() {\r\n        let { props, state, context } = this;\r\n        let { options } = context;\r\n        let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);\r\n        let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);\r\n        let tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);\r\n        let { slotMinWidth } = options;\r\n        let slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));\r\n        let sections = [\r\n            {\r\n                type: 'header',\r\n                key: 'header',\r\n                isSticky: stickyHeaderDates,\r\n                chunks: [{\r\n                        key: 'timeline',\r\n                        content: (contentArg) => (createElement(TimelineHeader, { dateProfile: props.dateProfile, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile: tDateProfile, slatCoords: state.slatCoords, onMaxCushionWidth: slotMinWidth ? null : this.handleMaxCushionWidth })),\r\n                    }],\r\n            },\r\n            {\r\n                type: 'body',\r\n                key: 'body',\r\n                liquid: true,\r\n                chunks: [{\r\n                        key: 'timeline',\r\n                        content: (contentArg) => (createElement(TimelineGrid, Object.assign({}, props, { clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile: tDateProfile, onSlatCoords: this.handleSlatCoords, onScrollLeftRequest: this.handleScrollLeftRequest }))),\r\n                    }],\r\n            },\r\n        ];\r\n        if (stickyFooterScrollbar) {\r\n            sections.push({\r\n                type: 'footer',\r\n                key: 'footer',\r\n                isSticky: true,\r\n                chunks: [{\r\n                        key: 'timeline',\r\n                        content: renderScrollShim,\r\n                    }],\r\n            });\r\n        }\r\n        return (createElement(ViewContainer, { elClasses: [\r\n                'fc-timeline',\r\n                options.eventOverlap === false ?\r\n                    'fc-timeline-overlap-disabled' :\r\n                    '',\r\n            ], viewSpec: context.viewSpec },\r\n            createElement(ScrollGrid, { ref: this.scrollGridRef, liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [\r\n                    { cols: slatCols },\r\n                ], sections: sections })));\r\n    }\r\n    computeFallbackSlotMinWidth(tDateProfile) {\r\n        return Math.max(30, ((this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel));\r\n    }\r\n}\r\nfunction buildSlatCols(tDateProfile, slotMinWidth) {\r\n    return [{\r\n            span: tDateProfile.slotCnt,\r\n            minWidth: slotMinWidth || 1, // needs to be a non-zero number to trigger horizontal scrollbars!??????\r\n        }];\r\n}\r\n\r\nvar css_248z = \".fc .fc-timeline-body{min-height:100%;position:relative;z-index:1}.fc .fc-timeline-slots{bottom:0;position:absolute;top:0;z-index:1}.fc .fc-timeline-slots>table{height:100%}.fc .fc-timeline-slot-minor{border-style:dotted}.fc .fc-timeline-slot-frame{align-items:center;display:flex;justify-content:center}.fc .fc-timeline-header-row-chrono .fc-timeline-slot-frame{justify-content:flex-start}.fc .fc-timeline-header-row:last-child .fc-timeline-slot-frame{overflow:hidden}.fc .fc-timeline-slot-cushion{padding:4px 5px;white-space:nowrap}.fc-direction-ltr .fc-timeline-slot{border-right:0!important}.fc-direction-rtl .fc-timeline-slot{border-left:0!important}.fc .fc-timeline-now-indicator-container{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:4}.fc .fc-timeline-now-indicator-arrow,.fc .fc-timeline-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;position:absolute;top:0}.fc .fc-timeline-now-indicator-arrow{border-left-color:transparent;border-right-color:transparent;border-width:6px 5px 0;margin:0 -6px}.fc .fc-timeline-now-indicator-line{border-width:0 0 0 1px;bottom:0;margin:0 -1px}.fc .fc-timeline-events{position:relative;width:0;z-index:3}.fc .fc-timeline-event-harness,.fc .fc-timeline-more-link{position:absolute;top:0}.fc-timeline-event{z-index:1}.fc-timeline-event.fc-event-mirror{z-index:2}.fc-timeline-event{align-items:center;border-radius:0;display:flex;font-size:var(--fc-small-font-size);margin-bottom:1px;padding:2px 1px;position:relative}.fc-timeline-event .fc-event-main{flex-grow:1;flex-shrink:1;min-width:0}.fc-timeline-event .fc-event-time{font-weight:700}.fc-timeline-event .fc-event-time,.fc-timeline-event .fc-event-title{padding:0 2px;white-space:nowrap}.fc-direction-ltr .fc-timeline-event.fc-event-end,.fc-direction-ltr .fc-timeline-more-link{margin-right:1px}.fc-direction-rtl .fc-timeline-event.fc-event-end,.fc-direction-rtl .fc-timeline-more-link{margin-left:1px}.fc-timeline-overlap-disabled .fc-timeline-event{margin-bottom:0;padding-bottom:5px;padding-top:5px}.fc-timeline-event:not(.fc-event-end):after,.fc-timeline-event:not(.fc-event-start):before{border-color:transparent #000;border-style:solid;border-width:5px;content:\\\"\\\";flex-grow:0;flex-shrink:0;height:0;margin:0 1px;opacity:.5;width:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-start):before,.fc-direction-rtl .fc-timeline-event:not(.fc-event-end):after{border-left:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-end):after,.fc-direction-rtl .fc-timeline-event:not(.fc-event-start):before{border-right:0}.fc-timeline-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;font-size:var(--fc-small-font-size);padding:1px}.fc-timeline-more-link-inner{display:inline-block;left:0;padding:2px;right:0}.fc .fc-timeline-bg{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:2}.fc .fc-timeline-bg .fc-non-business{z-index:1}.fc .fc-timeline-bg .fc-bg-event{z-index:2}.fc .fc-timeline-bg .fc-highlight{z-index:3}.fc .fc-timeline-bg-harness{bottom:0;position:absolute;top:0}\";\r\ninjectStyles(css_248z);\r\n\r\nexport { TimelineCoords, TimelineHeader, TimelineHeaderRows, TimelineLane, TimelineLaneBg, TimelineLaneSlicer, TimelineSlats, TimelineView, buildSlatCols, buildTimelineDateProfile, coordToCss, coordsToCss };\r\n", "import { createPlugin } from '@fullcalendar/core/index.js';\r\nimport premiumCommonPlugin from '@fullcalendar/premium-common/index.js';\r\nimport { TimelineView } from './internal.js';\r\nimport '@fullcalendar/core/internal.js';\r\nimport '@fullcalendar/core/preact.js';\r\nimport '@fullcalendar/scrollgrid/internal.js';\r\n\r\nvar index = createPlugin({\r\n    name: '@fullcalendar/timeline',\r\n    premiumReleaseDate: '2023-05-25',\r\n    deps: [premiumCommonPlugin],\r\n    initialView: 'timelineDay',\r\n    views: {\r\n        timeline: {\r\n            component: TimelineView,\r\n            usesMinMaxTime: true,\r\n            eventResizableFromStart: true, // how is this consumed for TimelineView tho?\r\n        },\r\n        timelineDay: {\r\n            type: 'timeline',\r\n            duration: { days: 1 },\r\n        },\r\n        timelineWeek: {\r\n            type: 'timeline',\r\n            duration: { weeks: 1 },\r\n        },\r\n        timelineMonth: {\r\n            type: 'timeline',\r\n            duration: { months: 1 },\r\n        },\r\n        timelineYear: {\r\n            type: 'timeline',\r\n            duration: { years: 1 },\r\n        },\r\n    },\r\n});\r\n\r\nexport { index as default };\r\n"],
  "mappings": "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",
  "names": ["scrollEl", "index", "isValidDate", "index"]
}
